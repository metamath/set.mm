<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/html4/loose.dtd">
<HTML LANG="EN-US">
<HEAD>

<!-- improve mobile display -->
<META NAME="viewport" CONTENT="width=device-width, initial-scale=1.0">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<TITLE>Home - Intuitionistic Logic Explorer</TITLE>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<LINK REL="shortcut icon" HREF="favicon.ico" TYPE="image/x-icon">

<STYLE TYPE="text/css">
<!--
/* Math symbol image will be shifted down 4 pixels to align with normal
  text for compatibility with various browsers.  The old ALIGN=TOP for
  math symbol images did not align in all browsers and should be deleted.
  All other images must override this shift with STYLE="margin-bottom:0px".
  (2-Oct-2015 nm) */
img { margin-bottom: -4px }
-->
</STYLE>

</HEAD>


<!-- <BODY BGCOLOR="#EEFFFA"> -->
<BODY BGCOLOR="#FFFFFF" STYLE="padding: 0px 8px">

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH="100%">

  <TR>
    <TD ALIGN=LEFT VALIGN=TOP><A HREF="../index.html"><IMG SRC="_icon-il.gif"
      BORDER=0
      ALT="Metamath Home"
      TITLE="Metamath Home"
      HEIGHT=32 WIDTH=32 ALIGN=TOP STYLE="margin-bottom:0px"></A>
    </TD>
    <TD ALIGN=CENTER VALIGN=TOP><FONT SIZE="+3"
      COLOR="#006633"><B>Intuitionistic Logic Explorer Home Page</B></FONT>
    </TD>

    <TD NOWRAP ALIGN=RIGHT VALIGN=TOP><FONT SIZE=-2
      FACE=sans-serif> <A HREF="wn.html">First &gt;</A><BR><A
      HREF="ax1hfs.html">Last &gt;</A></FONT>
    </TD>
  </TR>

  <TR>
    <TD COLSPAN=3 ALIGN=LEFT VALIGN=TOP><FONT SIZE=-2
      FACE=sans-serif>
      <A HREF="../mm.html">Mirrors</A>&nbsp; &gt;
        &nbsp;<A HREF="../index.html">Home</A>&nbsp; &gt;
      &nbsp;ILE Home&nbsp; &gt;
      &nbsp;<A HREF="mmtheorems.html">Th. List</A>&nbsp; &gt;
      &nbsp;<A HREF="mmrecent.html">Recent</A>
      </FONT>
    </TD>
  </TR>
</TABLE>

<HR NOSHADE SIZE=1>

<CENTER>
<B><FONT COLOR="#006633">Created by Mario Carneiro</FONT></B>
</CENTER>

<HR NOSHADE SIZE=1>
<B><FONT COLOR="#006633">Intuitionistic Logic Proof Explorer</FONT></B>


<!--
<P><I>Intuitionistic Logic</I> (<A
HREF="https://en.wikipedia.org/wiki/Intuitionistic_logic">Wikipedia</A>
[accessed 19-Jul-2015], <A
HREF="http://plato.stanford.edu/entries/logic-intuitionistic/"> Stanford
Encyclopedia of Philosophy</A> [accessed 19-Jul-2015]) is a logic weaker
than classical logic that can be thought of as a weakening of classical
logic such that the law of excluded middle, (<FONT
COLOR="#0000FF"><I>&phi;</I></FONT> <FONT FACE=sans-serif> &or;</FONT>
&not; <FONT COLOR="#0000FF"><I>&phi;</I></FONT>), doesn't always hold.
Specifically, it holds if we have a proof for <FONT
COLOR="#0000FF"><I>&phi;</I></FONT> or we have a proof for &not; <FONT
COLOR="#0000FF"><I>&phi;</I></FONT>, but it doesn't necessarily hold if
we don't have a proof of either one.  Intuitionistic logic can be
thought of as a constructive logic in which we must build and exhibit
concrete examples of objects before we can accept their existence.  A
proof by contradiction, where denial of an assertion to be proved leads
to asserting a falsehood, will generally not be valid in intuitionistic
logic.
-->

<!-- the above was replaced by David A. Wheeler: -->

<P><I>Intuitionistic Logic</I> (<A
HREF="https://en.wikipedia.org/wiki/Intuitionistic_logic">Wikipedia</A>
[accessed 19-Jul-2015], <A
HREF="http://plato.stanford.edu/entries/logic-intuitionistic/"> Stanford
Encyclopedia of Philosophy</A> [accessed 19-Jul-2015]) can be
thought of as a constructive logic in which we must build and exhibit
concrete examples of objects before we can accept their existence.
Unproved statements in intuitionistic logic are not given an intermediate truth value,
instead, they remain of unknown truth value until they are either proved or disproved.
Intuitionist logic can also be thought of as a weakening of classical
logic such that the law of excluded middle (LEM), (<FONT
COLOR="#0000FF"><I>&phi;</I></FONT> <FONT FACE=sans-serif> &or;</FONT>
&not; <FONT COLOR="#0000FF"><I>&phi;</I></FONT>), doesn't always hold.
Specifically, it holds if we have a proof for <FONT
COLOR="#0000FF"><I>&phi;</I></FONT> or we have a proof for &not; <FONT
COLOR="#0000FF"><I>&phi;</I></FONT>, but it doesn't necessarily hold if
we don't have a proof of either one.
There is also no rule for double negation elimination.
Brouwer observed in 1908 that LEM was abstracted from finite situations,
then extended without justification to statements about infinite collections.

<HR NOSHADE SIZE=1>



<TABLE  WIDTH="100%"><TR>

<TD VALIGN=top>
<B><FONT COLOR="#006633">Contents of this page</FONT></B>
<MENU>
  <LI> <A HREF="#overview">Overview of intuitionistic logic</A></LI>
  <LI> <A HREF="#overview2">Overview of this work</A></LI>
  <LI> <A HREF="#axioms">The axioms</A></LI>
  <LI> <A HREF="#theorems">Some theorems</A></LI>
  <LI> <A HREF="#intuitionize">How to intuitionize classical proofs</A></LI>
  <LI> <A HREF="#setmm">Metamath Proof Explorer cross reference</A></LI>
  <LI> <A HREF="#bib">Bibliography</A></LI>
</MENU></TD>

<TD VALIGN=top>
<B><FONT COLOR="#006633">Related pages</FONT></B>

<MENU>
<LI> <A HREF="mmtheorems.html">Table of Contents and Theorem List</A></LI>

<LI>
 <A HREF="mmrecent.html">Most Recent Proofs
 (this mirror)</A>
  (<A HREF="http://us2.metamath.org:88/ileuni/mmrecent.html">latest</A>)
    </LI>

<LI> <A HREF="mmbiblio.html">Bibliographic Cross-Reference</A></LI>
<LI> <A HREF="mmdefinitions.html">Definition List</A></LI>
<LI> <A HREF="mmascii.html">ASCII Equivalents for Text-Only Browsers</A></LI>
<LI>
<A HREF="../metamath/iset.mm">Metamath database iset.mm (ASCII file)</A>
</LI>
</MENU>

<B><FONT COLOR="#006633">External links</FONT></B>
<MENU>
<LI>
<A HREF=" https://github.com/metamath/set.mm">GitHub repository</A>
[accessed 06-Jan-2018]
</LI>
</MENU>

</TD>
</TR></TABLE>

<HR NOSHADE SIZE=1><A NAME="overview"></A><B><FONT COLOR="#006633">
Overview of intuitionistic logic</FONT></B>

<P>(Placeholder for future use)


<HR NOSHADE SIZE=1><A NAME="overview2"></A><B><FONT COLOR="#006633">
Overview of this work</FONT></B>

<P>(By G&eacute;rard Lang, 7-May-2018)

<P>Mario Carneiro's work (Metamath database)
 "iset.mm" provides in Metamath a development of
"set.mm" whose eventual
aim is to show how many of the theorems of set theory and
mathematics that can be derived from classical first order logic can
also be derived from a weaker system called "intuitionistic logic."  To
achieve this task, iset.mm adds (or substitutes) intuitionistic
axioms for a number of the classical logical axioms of set.mm.

<P>Among these new axioms, the 6 first
( ~ ax-ia1 ,
~ ax-ia2 ,
~ ax-ia3 ,
~ ax-io ,
~ ax-in1
and
~ ax-in2 ), when added to
~ ax-1 ,
~ ax-2
and
~ ax-mp ,
 allow for the development of intuitionistic
propositional logic.  We omit the classical axiom
<SPAN CLASS=math>((&not;
<SPAN CLASS=wff STYLE="color:blue">&#x1D711;</SPAN> &rarr; &not; <SPAN
CLASS=wff STYLE="color:blue">&#x1D713;</SPAN>) &rarr; (<SPAN CLASS=wff
STYLE="color:blue">&#x1D713;</SPAN> &rarr; <SPAN CLASS=wff
STYLE="color:blue">&#x1D711;</SPAN>))</SPAN> (which is ax-3 in
set.mm).  Each of our new axioms is a theorem of classical
propositional logic, but ax-3 cannot be derived from them.  Similarly,
other basic classical theorems, like the third middle excluded or the
equivalence of a proposition with its double negation, cannot be derived
in intuitionistic propositional calculus.  Glivenko showed that a
proposition <FONT COLOR="#0000FF"><I>&phi;</I></FONT>
 is a theorem of classical propositional calculus if and only
if &not;&not;<FONT COLOR="#0000FF"><I>&phi;</I></FONT>
 is a theorem of intuitionistic propositional calculus.

<P>The next 4 new axioms
( ~ ax-ial ,
~ ax-i5r ,
~ ax-ie1
and
~ ax-ie2 )
together with the set.mm axioms
~ ax-4 ,
~ ax-5 ,
~ ax-7
and
~ ax-gen
do not mention equality or distinct variables.

<P>The ~ ax-i9 axiom is
just a slight variation of the classical ~ ax-9 .
The classical axiom ~ ax-12 is strengthened
into first ~ ax-i12 and then
~ ax-bnd (two results which would be
fairly readily equivalent to ax-12 classically but which do not
follow from ax-12, at least not in an obvious way, in intuitionistic
logic).

The substitution of ax-i9,
ax-i12, and ax-bnd for ax-9 and ax-12 and the inclusion of
~ ax-8 ,
~ ax-10 ,
~ ax-11 ,
~ ax-13 ,
~ ax-14
and
~ ax-17
allow for the development of the
intuitionistic predicate calculus.

<P>Each of the new axioms is a theorem of classical first order
logic with equality.  But some axioms of classical first order logic
with equality, like ax-3, cannot be derived in the intuitionistic
predicate calculus.</P>

<P>One of the major interests of the intuitionistic predicate calculus
is that its use can be considered as a realization of the program of the
constructivist philosophical view of mathematics.


<HR NOSHADE SIZE=1><A NAME="axioms"></A><B><FONT COLOR="#006633">
The axioms</FONT></B>

<P>As with the <A HREF="mmset.html#axioms">classical axioms</A>
we have propositional logic and predicate logic.

<P>The axioms of intuitionistic propositional logic consist of some of the axioms from
classical propositional logic, plus additional axioms for the operation of the 'and',
'or' and 'not' connectives.

<CENTER>
<TABLE BORDER CELLSPACING=0 BGCOLOR="#EEFFFA"
SUMMARY="Axioms of intuitionistic propositional calculus">
<CAPTION><B>Axioms of intuitionistic propositional calculus</B></CAPTION>

<TR ALIGN=LEFT><TD> <A HREF="ax-1.html"> Axiom <I>Simp</I></A></TD>
<TD><FONT COLOR="#006633"><B>ax-1</B></FONT></TD>
<TD><FONT COLOR="#808080" FACE=sans-serif>&#8866; </FONT>(<FONT
COLOR="#0000FF"><I>&phi;</I></FONT> &rarr; (<FONT
COLOR="#0000FF"><I>&psi;</I></FONT> &rarr; <FONT
COLOR="#0000FF"><I>&phi;</I></FONT>))</TD>
</TR>

<TR ALIGN=LEFT><TD><A HREF="ax-2.html">Axiom <I>Frege</I></A></TD> <TD
NOWRAP><FONT COLOR="#006633"><B>ax-2</B></FONT></TD>
<TD>
<FONT COLOR="#808080" FACE=sans-serif>&#8866; </FONT>((<FONT
COLOR="#0000FF"><I>&phi;</I></FONT> &rarr; (<FONT
COLOR="#0000FF"><I>&psi;</I></FONT> &rarr; <FONT
COLOR="#0000FF"><I>&chi;</I></FONT>)) &rarr; ((<FONT
COLOR="#0000FF"><I>&phi;</I></FONT> &rarr; <FONT
COLOR="#0000FF"><I>&psi;</I></FONT>) &rarr; (<FONT
COLOR="#0000FF"><I>&phi;</I></FONT> &rarr; <FONT
COLOR="#0000FF"><I>&chi;</I></FONT>)))</TD>
</TR>

<TR ALIGN=LEFT><TD><A
HREF="ax-mp.html">Rule of Modus Ponens</A></TD> <TD NOWRAP><FONT
COLOR="#006633"><B>ax-mp</B></FONT></TD>
<TD>` |- ph `  &nbsp;&nbsp;&amp; &nbsp;
` |- ph -> ps `  &nbsp; &#x21D2; &nbsp; ` |- ps `</TD>
</TR>

<TR ALIGN=LEFT><TD><A
HREF="ax-ia1.html">Left 'and' elimination</A></TD><TD><FONT
COLOR="#006633"><B>ax-ia1</B></FONT></TD><TD>
` |- ( ( ph /\ ps ) -> ph ) `</TD></TR>

<TR ALIGN=LEFT><TD><A
HREF="ax-ia2.html">Right 'and' elimination</A></TD><TD><FONT
COLOR="#006633"><B>ax-ia2</B></FONT></TD><TD>
<FONT COLOR="#808080" FACE="sans-serif">&#8866; </FONT>((<FONT COLOR="#0000FF"><I>&phi;</I></FONT>
<FONT FACE="sans-serif">&and;</FONT> <FONT COLOR="#0000FF"><I>&psi;</I></FONT>) &rarr;
<FONT COLOR="#0000FF"><I>&psi;</I></FONT>)</TD></TR>

<TR ALIGN=LEFT><TD><A
HREF="ax-ia3.html">'And' introduction</A></TD><TD><FONT
COLOR="#006633"><B>ax-ia3</B></FONT></TD><TD>
<FONT COLOR="#808080" FACE="sans-serif">&#8866; </FONT>(<FONT COLOR="#0000FF"><I>&phi;</I></FONT>
&rarr; (<FONT COLOR="#0000FF"><I>&psi;</I></FONT> &rarr; (<FONT COLOR="#0000FF"><I>&phi;</I></FONT>
<FONT FACE="sans-serif">&and;</FONT> <FONT COLOR="#0000FF"><I>&psi;</I></FONT>)))</TD></TR>

<TR ALIGN="LEFT"><TD><A
HREF="ax-io.html">Definition of 'or'</A></TD><TD><FONT COLOR="#006633"><B>ax-io</B></FONT></TD><TD>
<FONT COLOR="#808080" FACE="sans-serif">&#8866; </FONT>(((<FONT COLOR="#0000FF"><I>&phi;</I></FONT>
<FONT FACE="sans-serif"> &or;</FONT> <FONT COLOR="#0000FF"><I>&chi;</I></FONT>)
&rarr; <FONT COLOR="#0000FF"><I>&psi;</I></FONT>)
&#x2194; ((<FONT COLOR="#0000FF"><I>&phi;</I></FONT> &rarr;
<FONT COLOR="#0000FF"><I>&psi;</I></FONT>) <FONT FACE="sans-serif">&and;</FONT>
(<FONT COLOR="#0000FF"><I>&chi;</I></FONT> &rarr; <FONT COLOR="#0000FF"><I>&psi;</I></FONT>)))

<TR ALIGN="LEFT"><TD><A
HREF="ax-in1.html">'Not' introduction</A></TD><TD><FONT COLOR="#006633"><b>ax-in1</B></FONT></TD><TD>
<FONT COLOR="#808080" FACE="sans-serif">&#8866;
</FONT>((<FONT COLOR="#0000FF"><I>&phi;</I></FONT> &rarr; &not; <FONT COLOR="#0000FF"><I>&phi;</I></FONT>)
&rarr; &not; <FONT COLOR="#0000FF"><I>&phi;</I></FONT>)</TD></TR>

<TR ALIGN="LEFT"><TD><A
HREF="ax-in2.html">'Not' elimination</A></TD><TD><FONT COLOR="#006633"><B>ax-in2</B></FONT></TD><TD>
<FONT COLOR="#808080" FACE="sans-serif">&#8866; </FONT>(&not; <FONT COLOR="#0000FF"><I>&phi;</I></FONT>
&rarr; (<FONT COLOR="#0000FF"><I>&phi;</I></FONT> &rarr; <FONT COLOR="#0000FF"><I>&psi;</I></FONT>))</TD></TR>

</TABLE>

</CENTER>

<P>Unlike in classical propositional logic, 'and' and 'or' are not readily defined in terms of
implication and 'not'. In particular, <FONT COLOR="#0000FF"><I>&phi;</I></FONT> &or;
<FONT COLOR="#0000FF"><I>&psi;</I></FONT> is not equivalent to &not; <FONT COLOR="#0000FF"><I>&phi;</I></FONT> &rarr;
<FONT COLOR="#0000FF"><I>&psi;</I></FONT>,
nor is <FONT COLOR="#0000FF"><I>&phi;</I></FONT> &rarr;
<FONT COLOR="#0000FF"><I>&psi;</I></FONT> equivalent to &not; <FONT COLOR="#0000FF"><I>&phi;</I></FONT> &or;
<FONT COLOR="#0000FF"><I>&psi;</I></FONT>, nor is <FONT COLOR="#0000FF"><I>&phi;</I></FONT> &and;
<FONT COLOR="#0000FF"><I>&psi;</I></FONT> equivalent to &not; (<FONT COLOR="#0000FF"><I>&phi;</I></FONT> &rarr; &not;
<FONT COLOR="#0000FF"><I>&psi;</I></FONT>).</P>

<P>The ax-in1 axiom is a form of proof by contradiction which does hold intuitionistically. That is, if
<FONT COLOR="#0000FF"><I>&phi;</I></FONT> implies a contradiction (such as its own negation),
then one can conclude &not; <FONT COLOR="#0000FF"><I>&phi;</I></FONT>. By contrast, assuming
&not; <FONT COLOR="#0000FF"><I>&phi;</I></FONT>
and then deriving a contradiction only serves to prove &not; &not; <FONT COLOR="#0000FF"><I>&phi;</I></FONT>,
which in intuitionistic logic is not the same as <FONT COLOR="#0000FF"><I>&phi;</I></FONT>.</P>

<P>The biconditional can be defined as the conjunction of two implications, as in
<A HREF="dfbi2.html">dfbi2</a> and <A HREF="df-bi.html">df-bi</a>.</P>

<P><A NAME="pcaxioms"></A><B><FONT COLOR="#006633">Predicate
logic</FONT></B> adds set variables (individual variables) and the ability to quantify
them with &#x2200; (for-all) and &#x2203; (there-exists). Unlike in classical logic, &#x2203;
cannot be defined in terms of &#x2200;. As in classical logic, we also add = for equality
(which is key to how we handle substitution in metamath) and &#x2208; (which for current
purposes can just be thought of as an arbitrary predicate, but which will later come to
mean set membership).</P>

<p>Our axioms are based on the classical set.mm predicate logic axioms, but adapted for
intuitionistic logic, chiefly by adding additional axioms for &#x2203; and also changing
some aspects of how we handle negations.</p>

<CENTER>
<TABLE BORDER CELLSPACING=0 BGCOLOR="#EEFFFA"
SUMMARY="Axioms of intuitionistic predicate logic">
<CAPTION><B>Axioms of intuitionistic predicate logic</B></CAPTION>

<TR ALIGN=LEFT><TD><A HREF="ax-4.html">Axiom of Specialization</A></TD>
<TD><FONT COLOR="#006633"><B>ax-4</B></FONT></TD><TD>
<SPAN ><FONT COLOR="#808080" FACE=sans-serif>&#8866; </FONT>(<FONT
FACE=sans-serif>&forall;</FONT><I><FONT COLOR="#FF0000">x</FONT></I><FONT
COLOR="#0000FF"><I>&phi;</I></FONT> &rarr; <FONT
COLOR="#0000FF"><I>&phi;</I></FONT>)</SPAN></TD></TR>

<TR ALIGN=LEFT><TD> <A HREF="ax-5.html">Axiom of Quantified Implication</A></TD>
<TD><FONT COLOR="#006633"><B>ax-5</B></FONT></TD><TD>
<SPAN ><FONT COLOR="#808080" FACE=sans-serif>&#8866; </FONT>(<FONT
FACE=sans-serif>&forall;</FONT><I><FONT COLOR="#FF0000">x</FONT></I>(<FONT
COLOR="#0000FF"><I>&phi;</I></FONT> &rarr; <FONT
COLOR="#0000FF"><I>&psi;</I></FONT>) &rarr; (<FONT
FACE=sans-serif>&forall;</FONT><I><FONT COLOR="#FF0000">x</FONT></I><FONT
COLOR="#0000FF"><I>&phi;</I></FONT> &rarr; <FONT
FACE=sans-serif>&forall;</FONT><I><FONT COLOR="#FF0000">x</FONT></I><FONT
COLOR="#0000FF"><I>&psi;</I></FONT>))</SPAN></TD></TR>

<TR ALIGN=LEFT><TD><A HREF="ax-i5r.html">The converse of ax-5o</A></TD>
<TD><FONT COLOR="#006633"><B>ax-i5r</B></FONT></TD><TD>
<SPAN ><FONT COLOR="#808080" FACE=sans-serif>&#8866; </FONT>((<FONT
FACE=sans-serif>&forall;</FONT><I><FONT COLOR="#FF0000">x</FONT></I><FONT
COLOR="#0000FF"><I>&phi;</I></FONT> &rarr; <FONT
FACE=sans-serif>&forall;</FONT><I><FONT COLOR="#FF0000">x</FONT></I><FONT
COLOR="#0000FF"><I>&psi;</I></FONT>) &rarr; <FONT
FACE=sans-serif>&forall;</FONT><I><FONT COLOR="#FF0000">x</FONT></I>(<FONT
FACE=sans-serif>&forall;</FONT><I><FONT COLOR="#FF0000">x</FONT></I><FONT
COLOR="#0000FF"><I>&phi;</I></FONT> &rarr; <FONT
COLOR="#0000FF"><I>&psi;</I></FONT>))</SPAN></TD></TR>

<TR ALIGN=LEFT><TD><A HREF="ax-7.html">Axiom of Quantifier Commutation</A></TD>
<TD><FONT COLOR="#006633"><B>ax-7</B></FONT></TD><TD>
<SPAN ><FONT COLOR="#808080" FACE=sans-serif>&#8866; </FONT>(<FONT
FACE=sans-serif>&forall;</FONT><I><FONT COLOR="#FF0000">x</FONT></I><FONT
FACE=sans-serif>&forall;</FONT><I><FONT COLOR="#FF0000">y</FONT></I><FONT
COLOR="#0000FF"><I>&phi;</I></FONT> &rarr; <FONT
FACE=sans-serif>&forall;</FONT><I><FONT COLOR="#FF0000">y</FONT></I><FONT
FACE=sans-serif>&forall;</FONT><I><FONT COLOR="#FF0000">x</FONT></I><FONT
COLOR="#0000FF"><I>&phi;</I></FONT>)</SPAN></TD></TR>

<TR ALIGN=LEFT><TD><A HREF="ax-gen.html">Rule of Generalization</A></TD>
<TD><FONT COLOR="#006633"><B>ax-gen</B></FONT></TD><TD>
<FONT COLOR="#808080" FACE=sans-serif>&#8866; </FONT><FONT
COLOR="#0000FF"><I>&phi;</I></FONT> &nbsp;&nbsp;=&gt; &nbsp;&nbsp;<SPAN >
<FONT COLOR="#808080" FACE=sans-serif>&#8866; </FONT><FONT
FACE=sans-serif>&forall;</FONT><I><FONT COLOR="#FF0000">x</FONT></I><FONT
COLOR="#0000FF"><I>&phi;</I></FONT></SPAN></TD></TR>

<TR ALIGN=LEFT><TD><A HREF="ax-ial.html"><SPAN ><I><FONT
COLOR="#FF0000">x</FONT></I></SPAN> is bound in <SPAN ><FONT
FACE=sans-serif>&forall;</FONT><I><FONT COLOR="#FF0000">x</FONT></I><FONT
COLOR="#0000FF"><I>&phi;</I></FONT></SPAN></A></TD>
<TD><FONT COLOR="#006633"><B>ax-ial</B></FONT></TD><TD>
<SPAN ><FONT COLOR="#808080" FACE=sans-serif>&#8866; </FONT>(<FONT
FACE=sans-serif>&forall;</FONT><I><FONT COLOR="#FF0000">x</FONT></I><FONT
COLOR="#0000FF"><I>&phi;</I></FONT> &rarr; <FONT
FACE=sans-serif>&forall;</FONT><I><FONT COLOR="#FF0000">x</FONT></I><FONT
FACE=sans-serif>&forall;</FONT><I><FONT COLOR="#FF0000">x</FONT></I><FONT
COLOR="#0000FF"><I>&phi;</I></FONT>)</SPAN></TD></TR>

<TR ALIGN=LEFT><TD><A HREF="ax-ie1.html"><SPAN ><I><FONT
COLOR="#FF0000">x</FONT></I></SPAN> is bound in <SPAN ><FONT
FACE=sans-serif>&exist;</FONT><I><FONT COLOR="#FF0000">x</FONT></I><FONT
COLOR="#0000FF"><I>&phi;</I></FONT></SPAN></A></TD>
<TD><FONT COLOR="#006633"><B>ax-ie1</B></FONT></TD><TD>
<SPAN ><FONT COLOR="#808080" FACE=sans-serif>&#8866; </FONT>(<FONT
FACE=sans-serif>&exist;</FONT><I><FONT COLOR="#FF0000">x</FONT></I><FONT
COLOR="#0000FF"><I>&phi;</I></FONT> &rarr; <FONT
FACE=sans-serif>&forall;</FONT><I><FONT COLOR="#FF0000">x</FONT></I><FONT
FACE=sans-serif>&exist;</FONT><I><FONT COLOR="#FF0000">x</FONT></I><FONT
COLOR="#0000FF"><I>&phi;</I></FONT>)</SPAN></TD></TR>

<TR ALIGN=LEFT><TD><A HREF="ax-ie2.html">Define existential
quantification</A></TD>
<TD><FONT COLOR="#006633"><B>ax-ie2</B></FONT></TD><TD>
<SPAN ><FONT COLOR="#808080" FACE=sans-serif>&#8866; </FONT>(<FONT
FACE=sans-serif>&forall;</FONT><I><FONT COLOR="#FF0000">x</FONT></I>(<FONT
COLOR="#0000FF"><I>&psi;</I></FONT> &rarr; <FONT
FACE=sans-serif>&forall;</FONT><I><FONT COLOR="#FF0000">x</FONT></I><FONT
COLOR="#0000FF"><I>&psi;</I></FONT>) &rarr; (<FONT
FACE=sans-serif>&forall;</FONT><I><FONT COLOR="#FF0000">x</FONT></I>(<FONT
COLOR="#0000FF"><I>&phi;</I></FONT> &rarr; <FONT
COLOR="#0000FF"><I>&psi;</I></FONT>) &harr; (<FONT
FACE=sans-serif>&exist;</FONT><I><FONT COLOR="#FF0000">x</FONT></I><FONT
COLOR="#0000FF"><I>&phi;</I></FONT> &rarr; <FONT
COLOR="#0000FF"><I>&psi;</I></FONT>)))</SPAN></TD></TR>

<TR ALIGN=LEFT><TD><A HREF="ax-8.html">Axiom of Equality</A></TD>
<TD><FONT COLOR="#006633"><B>ax-8</B></FONT></TD><TD>
<SPAN ><FONT COLOR="#808080" FACE=sans-serif>&#8866; </FONT>(<I><FONT
COLOR="#FF0000">x</FONT></I> = <I><FONT COLOR="#FF0000">y</FONT></I> &rarr;
(<I><FONT COLOR="#FF0000">x</FONT></I> = <I><FONT COLOR="#FF0000">z</FONT></I>
&rarr; <I><FONT COLOR="#FF0000">y</FONT></I> = <I><FONT
COLOR="#FF0000">z</FONT></I>))</SPAN></TD></TR>

<TR ALIGN=LEFT><TD><A HREF="ax-i9.html">Axiom of Existence</A></TD>
<TD><FONT COLOR="#006633"><B>ax-i9</B></FONT></TD><TD>
<SPAN ><FONT COLOR="#808080" FACE=sans-serif>&#8866; </FONT><FONT
FACE=sans-serif>&exist;</FONT><I><FONT COLOR="#FF0000">x</FONT></I> <I><FONT
COLOR="#FF0000">x</FONT></I> = <I><FONT
COLOR="#FF0000">y</FONT></I></SPAN></TD></TR>

<TR ALIGN=LEFT><TD><A HREF="ax-10.html">Axiom of Quantifier
Substitution</A></TD>
<TD><FONT COLOR="#006633"><B>ax-10</B></FONT></TD><TD>
<SPAN ><FONT COLOR="#808080" FACE=sans-serif>&#8866; </FONT>(<FONT
FACE=sans-serif>&forall;</FONT><I><FONT COLOR="#FF0000">x</FONT></I> <I><FONT
COLOR="#FF0000">x</FONT></I> = <I><FONT COLOR="#FF0000">y</FONT></I> &rarr;
<FONT FACE=sans-serif>&forall;</FONT><I><FONT COLOR="#FF0000">y</FONT></I>
<I><FONT COLOR="#FF0000">y</FONT></I> = <I><FONT
COLOR="#FF0000">x</FONT></I>)</SPAN></TD></TR>

<TR ALIGN=LEFT><TD><A HREF="ax-11.html">Axiom of Variable
Substitution</A></TD>
<TD><FONT COLOR="#006633"><B>ax-11</B></FONT></TD><TD>
<SPAN ><FONT COLOR="#808080" FACE=sans-serif>&#8866; </FONT>(<I><FONT
COLOR="#FF0000">x</FONT></I> = <I><FONT COLOR="#FF0000">y</FONT></I> &rarr;
(<FONT FACE=sans-serif>&forall;</FONT><I><FONT
COLOR="#FF0000">y</FONT></I><FONT COLOR="#0000FF"><I>&phi;</I></FONT> &rarr;
<FONT FACE=sans-serif>&forall;</FONT><I><FONT
COLOR="#FF0000">x</FONT></I>(<I><FONT COLOR="#FF0000">x</FONT></I> = <I><FONT
COLOR="#FF0000">y</FONT></I> &rarr; <FONT
COLOR="#0000FF"><I>&phi;</I></FONT>)))</SPAN></TD></TR>

<TR ALIGN=LEFT><TD><A HREF="ax-i12.html">Axiom of Quantifier
Introduction</A></TD>
<TD><FONT COLOR="#006633"><B>ax-i12</B></FONT></TD><TD>
<SPAN ><FONT COLOR="#808080" FACE=sans-serif>&#8866; </FONT>(<FONT
FACE=sans-serif>&forall;</FONT><I><FONT COLOR="#FF0000">z</FONT></I> <I><FONT
COLOR="#FF0000">z</FONT></I> = <I><FONT COLOR="#FF0000">x</FONT></I> <FONT
FACE=sans-serif> &or;</FONT> (<FONT FACE=sans-serif>&forall;</FONT><I><FONT
COLOR="#FF0000">z</FONT></I> <I><FONT COLOR="#FF0000">z</FONT></I> = <I><FONT
COLOR="#FF0000">y</FONT></I> <FONT FACE=sans-serif> &or;</FONT> <FONT
FACE=sans-serif>&forall;</FONT><I><FONT COLOR="#FF0000">z</FONT></I>(<I><FONT
COLOR="#FF0000">x</FONT></I> = <I><FONT COLOR="#FF0000">y</FONT></I> &rarr;
<FONT FACE=sans-serif>&forall;</FONT><I><FONT COLOR="#FF0000">z</FONT></I>
<I><FONT COLOR="#FF0000">x</FONT></I> = <I><FONT
COLOR="#FF0000">y</FONT></I>)))</SPAN></TD></TR>

<TR ALIGN=LEFT>
<TD><A HREF="ax-bnd.html">Axiom of Bundling</A></TD>
<TD><FONT COLOR="#006633"><B>ax-bnd</B></FONT></TD><TD>
<SPAN ><FONT COLOR="#808080" FACE=sans-serif>&#8866; </FONT>(<FONT
FACE=sans-serif>&forall;</FONT><I><FONT COLOR="#FF0000">z</FONT></I> <I><FONT
COLOR="#FF0000">z</FONT></I> = <I><FONT COLOR="#FF0000">x</FONT></I> <FONT
FACE=sans-serif> &or;</FONT> (<FONT FACE=sans-serif>&forall;</FONT><I><FONT
COLOR="#FF0000">z</FONT></I> <I><FONT COLOR="#FF0000">z</FONT></I> = <I><FONT
COLOR="#FF0000">y</FONT></I> <FONT FACE=sans-serif> &or;</FONT> <FONT
FACE=sans-serif>&forall;</FONT><I><FONT COLOR="#FF0000">x</FONT></I><FONT
FACE=sans-serif>&forall;</FONT><I><FONT COLOR="#FF0000">z</FONT></I>(<I><FONT
COLOR="#FF0000">x</FONT></I> = <I><FONT COLOR="#FF0000">y</FONT></I> &rarr;
<FONT FACE=sans-serif>&forall;</FONT><I><FONT COLOR="#FF0000">z</FONT></I>
<I><FONT COLOR="#FF0000">x</FONT></I> = <I><FONT
COLOR="#FF0000">y</FONT></I>)))</SPAN></TD></TR>

<TR ALIGN=LEFT><TD><A HREF="ax-13.html">Left Membership Equality</A></TD>
<TD><FONT COLOR="#006633"><B>ax-13</B></FONT></TD><TD>
<SPAN ><FONT COLOR="#808080" FACE=sans-serif>&#8866; </FONT>(<I><FONT
COLOR="#FF0000">x</FONT></I> = <I><FONT COLOR="#FF0000">y</FONT></I> &rarr;
(<I><FONT COLOR="#FF0000">x</FONT></I> <FONT FACE=sans-serif>&isin;</FONT>
<I><FONT COLOR="#FF0000">z</FONT></I> &rarr; <I><FONT
COLOR="#FF0000">y</FONT></I> <FONT FACE=sans-serif>&isin;</FONT> <I><FONT
COLOR="#FF0000">z</FONT></I>))</SPAN></TD></TR>

<TR ALIGN=LEFT><TD><A HREF="ax-14.html">Right Membership Equality</A></TD>
<TD><FONT COLOR="#006633"><B>ax-14</B></FONT></TD><TD>
<SPAN ><FONT COLOR="#808080" FACE=sans-serif>&#8866; </FONT>(<I><FONT
COLOR="#FF0000">x</FONT></I> = <I><FONT COLOR="#FF0000">y</FONT></I> &rarr;
(<I><FONT COLOR="#FF0000">z</FONT></I> <FONT FACE=sans-serif>&isin;</FONT>
<I><FONT COLOR="#FF0000">x</FONT></I> &rarr; <I><FONT
COLOR="#FF0000">z</FONT></I> <FONT FACE=sans-serif>&isin;</FONT> <I><FONT
COLOR="#FF0000">y</FONT></I>))</SPAN></TD></TR>

<TR ALIGN=LEFT><TD><A HREF="ax-17.html">Distinctness</A></TD>
<TD><FONT COLOR="#006633"><B>ax-17</B></FONT></TD><TD>
<SPAN ><FONT COLOR="#808080" FACE=sans-serif>&#8866; </FONT>(<FONT
COLOR="#0000FF"><I>&phi;</I></FONT> &rarr; <FONT
FACE=sans-serif>&forall;</FONT><I><FONT COLOR="#FF0000">x</FONT></I><FONT
COLOR="#0000FF"><I>&phi;</I></FONT>)</SPAN>,
where <FONT COLOR="#FF0000">x</FONT> does not occur in <FONT
COLOR="#0000FF"><I>&phi;</I></FONT></TD></TR>

</TABLE>
</CENTER>

<P><A NAME="staxioms"></A><B><FONT COLOR="#006633">Set theory</FONT></B>
uses the formalism of propositional and predicate calculus to assert
properties of arbitrary mathematical objects called "sets."  A set can
be an element of another set, and this relationship is indicated by the
<IMG SRC='in.gif' WIDTH=10 HEIGHT=19 ALT='e.'> symbol.
Starting with the simplest mathematical object, called the empty set,
set theory builds up more and more complex structures whose existence
follows from the axioms, eventually resulting in extremely complicated
sets that we identify with the real numbers and other familiar
mathematical objects.  These axioms were developed in response to <A
HREF="ru.html">Russell's Paradox</A>, a discovery that revolutionized
the foundations of mathematics and logic.</P>

<P><A NAME="izfaxioms"></A> In the IZF axioms that follow, <I>all set
variables are assumed to be</I> <A HREF="#distinct">distinct</A>.  If
you click on their links you will see the explicit distinct variable
conditions.</P>

<CENTER><TABLE BORDER CELLSPACING=0 BGCOLOR="#EEFFFA"
SUMMARY="Intuitionistic Zermelo-Fraenkel Set Theory (IZF)">
<CAPTION><B>Intuitionistic Zermelo-Fraenkel Set Theory (IZF)</B></CAPTION>

<TR ALIGN=LEFT><TD><A HREF="ax-ext.html">Axiom of Extensionality</A></TD>
<TD NOWRAP><FONT COLOR="#006633"><B>ax-ext</B></FONT></TD>
<TD>
<SPAN ><FONT COLOR="#808080" FACE=sans-serif>&#8866; </FONT>(<FONT
FACE=sans-serif>&forall;</FONT><I><FONT COLOR="#FF0000">z</FONT></I>(<I><FONT
COLOR="#FF0000">z</FONT></I> <FONT FACE=sans-serif>&isin;</FONT> <I><FONT
COLOR="#FF0000">x</FONT></I> &harr; <I><FONT COLOR="#FF0000">z</FONT></I> <FONT
FACE=sans-serif>&isin;</FONT> <I><FONT COLOR="#FF0000">y</FONT></I>) &rarr;
<I><FONT COLOR="#FF0000">x</FONT></I> = <I><FONT
COLOR="#FF0000">y</FONT></I>)</SPAN></TD></TR>

<TR ALIGN=LEFT>
<TD><A HREF="ax-coll.html">Axiom of Collection</A></TD>
<TD><FONT COLOR="#006633"><B>ax-coll</B></FONT></TD><TD>
<SPAN CLASS=math><FONT COLOR="#808080" FACE=sans-serif>&#8866; </FONT>(<FONT
FACE=sans-serif>&forall;</FONT><I><FONT COLOR="#FF0000">x</FONT></I> <FONT
FACE=sans-serif>&isin;</FONT> <SPAN CLASS=set
STYLE="color:red">&#x1D44E;</SPAN> <FONT FACE=sans-serif>&exist;</FONT><I><FONT
COLOR="#FF0000">y</FONT></I><FONT COLOR="#0000FF"><I>&phi;</I></FONT> &rarr;
<FONT FACE=sans-serif>&exist;</FONT><SPAN CLASS=set
STYLE="color:red">&#x1D44F;</SPAN><FONT FACE=sans-serif>&forall;</FONT><I><FONT
COLOR="#FF0000">x</FONT></I> <FONT FACE=sans-serif>&isin;</FONT> <SPAN
CLASS=set STYLE="color:red">&#x1D44E;</SPAN> <FONT
FACE=sans-serif>&exist;</FONT><I><FONT COLOR="#FF0000">y</FONT></I> <FONT
FACE=sans-serif>&isin;</FONT> <SPAN CLASS=set
STYLE="color:red">&#x1D44F;</SPAN> <FONT
COLOR="#0000FF"><I>&phi;</I></FONT>)</SPAN></TD></TR>

<TR ALIGN=LEFT>
<TD><A HREF="ax-sep.html">Axiom of Separation</A></TD>
<TD><FONT COLOR="#006633"><B>ax-sep</B></FONT></TD><TD>
<SPAN CLASS=math><FONT COLOR="#808080" FACE=sans-serif>&#8866; </FONT><FONT
FACE=sans-serif>&exist;</FONT><I><FONT COLOR="#FF0000">y</FONT></I><FONT
FACE=sans-serif>&forall;</FONT><I><FONT COLOR="#FF0000">x</FONT></I>(<I><FONT
COLOR="#FF0000">x</FONT></I> <FONT FACE=sans-serif>&isin;</FONT> <I><FONT
COLOR="#FF0000">y</FONT></I> &harr; (<I><FONT COLOR="#FF0000">x</FONT></I>
<FONT FACE=sans-serif>&isin;</FONT> <I><FONT COLOR="#FF0000">z</FONT></I> <FONT
FACE=sans-serif>&and;</FONT> <FONT
COLOR="#0000FF"><I>&phi;</I></FONT>))</SPAN></TD></TR>

<TR ALIGN=LEFT>
<TD><A HREF="ax-pow.html">Axiom of Power Sets</A></TD>
<TD><FONT COLOR="#006633"><B>ax-pow</B></FONT></TD><TD>
<SPAN CLASS=math><FONT COLOR="#808080" FACE=sans-serif>&#8866; </FONT><FONT
FACE=sans-serif>&exist;</FONT><I><FONT COLOR="#FF0000">y</FONT></I><FONT
FACE=sans-serif>&forall;</FONT><I><FONT COLOR="#FF0000">z</FONT></I>(<FONT
FACE=sans-serif>&forall;</FONT><I><FONT COLOR="#FF0000">w</FONT></I>(<I><FONT
COLOR="#FF0000">w</FONT></I> <FONT FACE=sans-serif>&isin;</FONT> <I><FONT
COLOR="#FF0000">z</FONT></I> &rarr; <I><FONT COLOR="#FF0000">w</FONT></I> <FONT
FACE=sans-serif>&isin;</FONT> <I><FONT COLOR="#FF0000">x</FONT></I>) &rarr;
<I><FONT COLOR="#FF0000">z</FONT></I> <FONT FACE=sans-serif>&isin;</FONT>
<I><FONT COLOR="#FF0000">y</FONT></I>)</SPAN></TD></TR>

<TR ALIGN=LEFT>
<TD><A HREF="ax-pr.html">Axiom of Pairing</A></TD>
<TD><FONT COLOR="#006633"><B>ax-pr</B></FONT></TD><TD>
<SPAN CLASS=math><FONT COLOR="#808080" FACE=sans-serif>&#8866; </FONT><FONT
FACE=sans-serif>&exist;</FONT><I><FONT COLOR="#FF0000">z</FONT></I><FONT
FACE=sans-serif>&forall;</FONT><I><FONT COLOR="#FF0000">w</FONT></I>((<I><FONT
COLOR="#FF0000">w</FONT></I> = <I><FONT COLOR="#FF0000">x</FONT></I> <FONT
FACE=sans-serif> &or;</FONT> <I><FONT COLOR="#FF0000">w</FONT></I> = <I><FONT
COLOR="#FF0000">y</FONT></I>) &rarr; <I><FONT COLOR="#FF0000">w</FONT></I>
<FONT FACE=sans-serif>&isin;</FONT> <I><FONT
COLOR="#FF0000">z</FONT></I>)</SPAN></TD></TR>

<TR ALIGN=LEFT>
<TD><A HREF="ax-un.html">Axiom of Union</A></TD>
<TD><FONT COLOR="#006633"><B>ax-un</B></FONT></TD><TD>
<SPAN CLASS=math><FONT COLOR="#808080" FACE=sans-serif>&#8866; </FONT><FONT
FACE=sans-serif>&exist;</FONT><I><FONT COLOR="#FF0000">y</FONT></I><FONT
FACE=sans-serif>&forall;</FONT><I><FONT COLOR="#FF0000">z</FONT></I>(<FONT
FACE=sans-serif>&exist;</FONT><I><FONT COLOR="#FF0000">w</FONT></I>(<I><FONT
COLOR="#FF0000">z</FONT></I> <FONT FACE=sans-serif>&isin;</FONT> <I><FONT
COLOR="#FF0000">w</FONT></I> <FONT FACE=sans-serif>&and;</FONT> <I><FONT
COLOR="#FF0000">w</FONT></I> <FONT FACE=sans-serif>&isin;</FONT> <I><FONT
COLOR="#FF0000">x</FONT></I>) &rarr; <I><FONT COLOR="#FF0000">z</FONT></I>
<FONT FACE=sans-serif>&isin;</FONT> <I><FONT
COLOR="#FF0000">y</FONT></I>)</SPAN></TD></TR>

<TR ALIGN=LEFT>
<TD><A HREF="ax-setind.html">Axiom of Set Induction</A></TD>
<TD><FONT COLOR="#006633"><B>ax-setind</B></FONT></TD><TD>
<SPAN CLASS=math><FONT COLOR="#808080" FACE=sans-serif>&#8866; </FONT>(<FONT
FACE=sans-serif>&forall;</FONT><SPAN CLASS=set
STYLE="color:red">&#x1D44E;</SPAN>(<FONT
FACE=sans-serif>&forall;</FONT><I><FONT COLOR="#FF0000">y</FONT></I> <FONT
FACE=sans-serif>&isin;</FONT> <SPAN CLASS=set
STYLE="color:red">&#x1D44E;</SPAN> [<I><FONT COLOR="#FF0000">y</FONT></I> /
<SPAN CLASS=set STYLE="color:red">&#x1D44E;</SPAN>]<FONT
COLOR="#0000FF"><I>&phi;</I></FONT> &rarr; <FONT
COLOR="#0000FF"><I>&phi;</I></FONT>) &rarr; <FONT
FACE=sans-serif>&forall;</FONT><SPAN CLASS=set
STYLE="color:red">&#x1D44E;</SPAN><FONT
COLOR="#0000FF"><I>&phi;</I></FONT>)</SPAN></TD>
</TR>

<TR ALIGN=LEFT>
<TD><A HREF="ax-iinf.html">Axiom of Infinity</A></TD>
<TD><FONT COLOR="#006633"><B>ax-iinf</B></FONT></TD><TD>
<SPAN CLASS=math><FONT COLOR="#808080" FACE=sans-serif>&#8866; </FONT><FONT
FACE=sans-serif>&exist;</FONT><I><FONT COLOR="#FF0000">x</FONT></I>(&empty;
<FONT FACE=sans-serif>&isin;</FONT> <I><FONT COLOR="#FF0000">x</FONT></I> <FONT
FACE=sans-serif>&and;</FONT> <FONT FACE=sans-serif>&forall;</FONT><I><FONT
COLOR="#FF0000">y</FONT></I>(<I><FONT COLOR="#FF0000">y</FONT></I> <FONT
FACE=sans-serif>&isin;</FONT> <I><FONT COLOR="#FF0000">x</FONT></I> &rarr; suc
<I><FONT COLOR="#FF0000">y</FONT></I> <FONT FACE=sans-serif>&isin;</FONT>
<I><FONT COLOR="#FF0000">x</FONT></I>))</SPAN>
</TD></TR>

</TABLE></CENTER>

<P>We develop set theory based on the Intuitionistic Zermelo-Fraenkel
(IZF) system, mostly following the IZF axioms as laid out in [Crosilla].
Constructive Zermelo-Fraenkel (CZF), also described in Crosilla, is not
as easy to formalize in metamath because the Axiom of Restricted Separation
would require us to develop the ability to classify formulas as bounded
formulas, similar to the machinery we have built up for asserting on
whether variables are free in formulas.</P>

<P></P><HR NOSHADE SIZE=1><A NAME="theorems"></A><B><FONT COLOR="#006633">A
Theorem Sampler</FONT></B>&nbsp;&nbsp;&nbsp;

<P></P><CENTER><FONT COLOR="#006633"><I>From a psychological point of view,
learning constructive mathematics is agonizing, for it requires one to
first unlearn certain deeply ingrained intuitions and
habits acquired during classical mathematical training.</I>
<BR> &mdash;Andrej Bauer</FONT></CENTER>

<P>Listed here are some examples of starting points for your journey
through the maze.  Some are stated just as they would be in a
non-constructive context; others are here to highlight areas which
look different constructively.
You should study some simple proofs from
propositional calculus until you get the hang of it.  Then try some
predicate calculus and finally set theory.</P>

<P>The <A HREF="mmtheorems.html">Theorem List</A> shows the complete set of
theorems in the database.  You may also find the <A
HREF="mmbiblio.html">Bibliographic Cross-Reference</A> useful.</P>


<P><TABLE BORDER=0><TR><TD VALIGN=TOP WIDTH="50%"><TR><TD VALIGN=TOP WIDTH="50%">
<B>Propositional calculus</B>
<MENU>
<LI>
<A HREF="id1.html">Law of identity</A></LI>

<LI>
<A HREF="prth.html">Praeclarum theorema</A></LI>

<LI>
<A HREF="con3.html">Contraposition introduction</A></LI>

<LI>
<A HREF="notnot1.html">Double negation introduction</A></LI>

<LI>
<A HREF="notnotnot.html">Triple negation</A></LI>

<LI>
<A HREF="df-xor.html">Definition of exclusive or</A></LI>

<LI>
<A HREF="dfnot.html">Negation and the false constant</A></LI>
</MENU>
<B>Predicate calculus</B>
<MENU>
<LI>
<A HREF="19.12.html">Existential and universal quantifier swap</A></LI>

<LI>
<A HREF="19.35-1.html">Existentially quantified implication</A></LI>

<LI>
<A HREF="equid.html"><I>x</I> = <I>x</I></A></LI>

<LI>
<A HREF="df-sb.html">Definition of proper substitution</A></LI>

<LI>
<A HREF="2eu7.html">Double existential uniqueness</A></LI>

</MENU>
<B>Set theory</B>
<MENU>
<LI>
<A HREF="uncom.html">Commutative law for union</A></LI>

<LI>
<A HREF="abeq2.html">A basic relationship between class and wff
variables</A></LI>

<LI>
<A HREF="isset.html">Two ways of saying &quot;is a set&quot;</A></LI>

<LI>
<A HREF="regexmid.html">The ZF axiom of foundation implies excluded middle</A></LI>

<LI>
<A HREF="ru.html">Russell's paradox</A></LI>

<LI>
<A HREF="ordtriexmid.html">Ordinal trichotomy implies excluded middle</A></LI>

<LI>
<A HREF="findes.html">Mathematical (finite) induction</A></LI>

<LI>Peano's postulates for arithmetic:
<A HREF="peano1.html">1</A>
<A HREF="peano2.html">2</A>
<A HREF="peano3.html">3</A>
<A HREF="peano4.html">4</A>
<A HREF="peano5.html">5</A></LI>

<LI><A HREF="nndceq.html">Two natural numbers are either equal or not equal</A> (a special case of the law of the excluded middle which we can prove).</LI>

<LI><A HREF="nn0suc.html">A natural number is either zero or a successor</A></LI>

<LI>
<A HREF="acexmid.html">The axiom of choice implies excluded middle</A></LI>

<LI>
<A HREF="onprc.html">Burali-Forti paradox</A></LI>

<LI>
<A HREF="tfis3.html">Transfinite induction</A></LI>

<LI>
<A HREF="oacl.html">Closure law for ordinal addition</A></LI>

</MENU>
<B>Real and complex numbers</B>

<MENU>
<LI>Properties of apartness:
<A HREF="apirr.html">1</A>
<A HREF="apsym.html">2</A>
<A HREF="apcotr.html">3</A>
<A HREF="apti.html">4</A></LI>

</MENU>
</TD></TR></TABLE>

<HR NOSHADE SIZE=1><A NAME="intuitionize"></A><B><FONT
COLOR="#006633">How to intuitionize classical proofs</FONT></B>&nbsp;&nbsp;&nbsp;

<P>For the student or master of classical mathematics, constructive mathematics
can be baffling. One can get over some of the intial hurdles of understanding
how constructive mathematics works and why it might be interesting by reading
<A HREF="#Bauer">[Bauer]</A> but that work does little to explain in concrete terms how to write
proofs in intuitionistic logic. Fortunately, metamath helps with one of the
biggest hurdles: noticing when one is even using the law of the excluded
middle or the axiom of choice. But suppose you have a classical proof from
the Metamath Proof Explorer and it fails to verify when you copy it over to
the Intuitionistic Logic Explorer. What then? Here are some rules of thumb
in converting classical proofs to intuitionistic ones.</P>

<UL>

<LI>If you see case elimination ( pm2.61 or its variants) you'll probably end up with two theorems for the two cases. In particular, if the cases were ` A e. _V ` and ` -. A e. _V ` you probably just care about the ` A e. _V ` case.</LI>

<LI>
Non-empty almost always needs to be changed to inhabited (those terms are defined at ~ n0rf ).
</LI>

<LI>If the original proof relied on propositional/predicate logic which isn't a theorem of intuitionistic logic, maybe there is a way of expressing the logic more directly. This is perhaps the hardest one to put in cookbook form: you might need to try some things and see if anything works.</LI>

<LI>If the original proof relied on df-ex so that it could prove a theorem for ` A. ` and then get ` E. ` for free (or vice versa), instead go look at the original proof and try to come up the analogues to each step for the other quantifier (for example, ~ cbvrexcsf , ~ sbcrext , ~ rexxpf ). Similarly, if you have a theorem for ` <_ ` and are trying to prove the corresponding theorem for ` < ` you'll probably need to use analogous steps rather than negation (examples: ~ leaddsub , ~ ltsub1 , ~ ltsub2 ).</LI>

<LI>If you are dealing with a definition, try to find the best constructive definition from the literature ([HoTT] book, Stanford Encyclopedia of Philosophy, [Bauer], etc). Once you pick a definition, that'll affect the proofs which rely on that definition.</LI>

<LI>If there is case elimination on whether variables are distinct, most of the time you just need the variant with distinct variables. Sometimes you can then remove the constraint with a temporary variable (e.g. the various sbco2* variants, ~ nfralya , ~ r19.3rm ).</LI>

<LI>Sometimes one direction of a biconditional holds, or subset holds instead of equality. You might be able to keep the easy direction and worry about the other one later.</LI>

<LI>
If there is case elimination sometimes only one of the two cases is possible.
For example, in ~ mosubopt the rest of the formula being proved constrains
which case matters.
</LI>

<LI>
If you need an additional condition (for example, because the original proof
used case elimination) and you are proving a biconditional, consider whether
both sides of the biconditional imply the condition. If so, you'll be able to
prove the biconditional with that condition as an antecedent, and then use
~ pm5.21nii or one of its variants to remove the antecedent (example:
~ elxp4 ).
</LI>

<LI>
If your proof relies on dveeq2 try ~ dveeq2or and likewise for the other things
downstream of ~ ax-i12 or ~ ax-bnd .
</LI>

<LI>
If you have a disjunction, be reluctant to turn it into an implication using
~ ord and the like. Instead, show that each disjunct implies what you are
trying to prove and use ~ jaoi to join those two implications into something
which can hook up to the disjunction.
</LI>

<LI>
Disjunctive syllogism holds in intuitionistic logic and we state it a few ways
(for example ~ orel1 and ~ ecased ) but we don't have a wide variety of
convenience theorems. Unless we add those, you'll use ~ ord or something
similar followed by ~ mpd or something similar. This may add a few steps but
they are straightforward ones.
</LI>

<LI>
If your proof is doing tricky things perhaps in the interest of shortness, try
just expanding the definitions and applying logic in a straightforward way. See
if this gets you a working (although perhaps longer) proof.
</LI>

<LI>
If your proof relies on a biconditional in set.mm which isn't in iset.mm, see
if one direction is in iset.mm and see which direction your proof is using. For
example ~ 19.35-1 or ~ exnalim .
</LI>

<LI>
If you are doing things with inhabited classes (beyond just applying existing
inhabited class theorems), you may be able to dig up some predicate logic you
haven't used in a while (e.g. ~ raaan ).
</LI>

<LI>
Consider the possibility of giving up. Some things just won't have
intuitionistic proofs. The more it looks like excluded middle or other
non-intuitionistic statements, the more likely you are dealing with one of
these. But it can be hard to have good intuition about this. In some cases it
may be possible to ask "can I use this statement to prove ` ph \/ -. ph ` for an
arbitrary proposition" (see ~ ordtriexmid for example ), but this is not always
an easy technique to apply.
</LI>

<LI>
Switching between ~ 2th and ~ 2false might help (e.g. ~ dfnul2 , ~ dfnul3 ,
~ rab0 ).
</LI>

<LI>
In many cases statements which are equivalent in classical logic become several
non-equivalent statements (e.g. exclusive or, ordinals, non-empty versus
inhabited, apartness versus negated equality). This is usually a good place to
look for a literature reference, but don't be afraid to change the statement
being proved to "what you really meant is X" as appropriate.
</LI>

<LI>
If a statement has multiple equivalences in set.mm (e.g. mo2 and mo3 , or
dffun2 and dffun3 ) and only some of them in iset.mm, sometimes a pretty
similar proof will work (that is, which one to use in the original proof may
have been a fairly arbitrary choice).
</LI>

<LI>
A number of theorems related to functions (especially ovex and fvex ) in
set.mm perform case elimination based on whether we are evaluating the function
within its domain or outside it. The most straightforward solution is to
use ~ fnovex or ~ funfvex which only work within the domain. Using these
may involve rearranging logic, for example by changing ~ rexlimivw to
~ rexlimdva (example: ~ ovelrn or indeed most uses of ~ fnovex and ~ funfvex ).
If a function value is inhabited, we know we are evaluating it within
its domain by ~ relelfvdm .
</LI>

<LI>
With excluded middle, ` (/) e. A ` and ` A =/= (/) ` are equivalent (where
` A ` is an ordinal). In such theorems, ` (/) e. A ` is generally the more
interesting condition constructively.</LI>

<LI>
Reverse closure in set.mm uses excluded middle (for example ovrcl or ndmfvrcl
). The most general way to handle this is to add more conditions that we are
evaluating operations within
their domains (for example set.mm's addasspi versus iset.mm's ~ addasspig in
which conditions such as ` A e. N. ` are added, or set.mm's ltbtwnnq versus
iset.mm's ~ ltbtwnnqq , in which ` E. x ` is changed to ` E. x e. Q. ` ).
If the result of applying a function is inhabited, then we know we applied
it within its domain - that is ~ relelfvdm or ~ elmpt2cl may be useful.
</LI>

<LI>
With excluded middle not equal (` =/= `) and apart (` # `) are equivalent.
When working with real and complex numbers, apartness is almost always what
you want. See ~ df-ap for more on apartness.
</LI>

<LI>Exclusive or ( ` ph \/_ ps ` ) is equivalent to ` ph <-> -. ps `
given excluded middle but we just have one direction ( ~ xorbin ).
Consider intuitionizing ` ph <-> -. ps ` as ` ph \/_ ps `
(example: ~ rpnegap ).</LI>

<LI>
If you get stuck, ask! (for example in a GitHub issue or on the mailing list).
We have a number of contributors who have experience in constructive
mathematics in general, or iset.mm in particular, and one of the best things
about doing/learning mathematics in metamath is the collaborative nature of how
we develop it.
</UL>

<HR NOSHADE SIZE=1><A NAME="setmm"></A>
<B><FONT COLOR="#006633">Metamath Proof Explorer cross
reference</FONT></B>&nbsp;&nbsp;&nbsp;

<P>This is a list of theorems from the Metamath Proof Explorer (which
assumes the law of the excluded middle throughout) which we do not
have in the Intuitionistic Logic Explorer (generally because they
are not provable without the law of the excluded middle, although some
could be proved but aren't for a variety of reasons), together
with the closest replacements.</P>

<TABLE BORDER CELLSPACING=0 BGCOLOR="#EEFFFA">
<TR>
<TH>set.mm</TH>
<TH>iset.mm</TH>
<TH>notes</TH>
</TR>

<TR>
<TD>ax-3 , con4d , con34b , necon4bd</TD>
<TD>~ con3 </TD>
<TD>The form of contraposition which removes negation does not hold
in intutionistic logic.</TD>
</TR>

<TR>
<TD>pm2.18</TD>
<TD>~ pm2.01 </TD>
<TD>See for example [Bauer] who uses the terminology "proof of negation"
versus "proof by contradiction" to distinguish these.</TD>
</TR>

<TR>
<TD>pm2.18d</TD>
<TD>~ pm2.01d</TD>
<TD>See for example [Bauer] who uses the terminology "proof of negation"
versus "proof by contradiction" to distinguish these.</TD>
</TR>

<TR>
<TD>notnotrd , notnotri , notnot2 , notnot</TD>
<TD>~ notnot1 </TD>
<TD>Double negation introduction holds but not double negation
elimination.</TD>
</TR>

<TR>
<TD>mt3d</TD>
<TD>~ mtod </TD>
</TR>

<TR>
<TD>nyl2</TD>
<TD>~ nsyl </TD>
</TR>

<TR>
<TD>pm2.61 , pm2.61d , pm2.61d1 , pm2.61d2 , pm2.61i , pm2.61ii , pm2.61nii ,
pm2.61iii , pm2.61ian , pm2.61dan , pm2.61ddan , pm2.61dda , pm2.61ine , pm2.61ne ,
pm2.61dne , pm2.61dane , pm2.61da2ne , pm2.61da3ne , pm2.61iine
</TD>
<TD><I>none</I></TD>
</TR>

<TR>
<TD>impcon4bid, con4bid, notbi, con1bii, con4bii, con2bii</TD>
<TD>~ con3 , ~ condc</TD>
</TR>

<TR>
<TD>xor3 , nbbn</TD>
<TD>~ xorbin , ~ xornbi , ~ xor3dc , ~ nbbndc </TD>
</TR>

<TR>
<TD>biass</TD>
<TD>~ biassdc </TD>
</TR>

<TR>
<TD>df-or , pm4.64 , pm2.54 , orri , orrd</TD>
<TD>~ pm2.53 , ~ ori , ~ ord </TD>
</TR>

<TR>
<TD>pm4.63</TD>
<TD>~ pm3.2im </TD>
</TR>

<TR>
<TD>iman</TD>
<TD>~ imanim </TD>
</TR>

<TR>
<TD>annim</TD>
<TD>~ annimim </TD>
</TR>

<TR>
<TD>oran</TD>
<TD>~ oranim </TD>
</TR>

<TR>
<TD>ianor</TD>
<TD>~ pm3.14 </TD>
</TR>

<TR>
<TD>biluk</TD>
<TD>~ bilukdc </TD>
</TR>

<TR>
<TD>ecase3d</TD>
<TD><I>none</I></TD>
<TD>This is a form of case elimination.<TD>
</TR>

<TR>
<TD>dedlem0b</TD>
<TD>~ dedlemb </TD>
</TR>

<TR>
<TD>3ianor</TD>
<TD>~ 3ianorr </TD>
</TR>

<TR>
<TD>df-ex</TD>
<TD>~ exalim </TD>
</TR>

<TR>
<TD>alex</TD>
<TD>~ alexim </TD>
</TR>

<TR>
<TD>exnal</TD>
<TD>~ exnalim </TD>
</TR>

<TR>
<TD>alexn</TD>
<TD>~ alexnim </TD>
</TR>

<TR>
<TD>exanali</TD>
<TD>~ exanaliim </TD>
</TR>

<TR>
<TD>19.35</TD>
<TD>~ 19.35-1 </TD>
</TR>

<TR>
<TD>19.30</TD>
<TD><I>none</I>
</TR>

<TR>
<TD>19.36</TD>
<TD>~ 19.36-1 </TD>
</TR>

<TR>
<TD>19.37</TD>
<TD>~ 19.37-1 </TD>
</TR>

<TR>
<TD>19.32</TD>
<TD>~ 19.32r </TD>
</TR>

<TR>
<TD>19.31</TD>
<TD>~ 19.31r </TD>
</TR>

<TR>
<TD>exdistrf</TD>
<TD>~ exdistrfor </TD>
</TR>

<TR>
<TD>exmo</TD>
<TD>~ exmonim </TD>
</TR>

<TR>
<TD>mo2</TD>
<TD>~ mo2r , ~ mo3 </TD>
</TR>

<TR>
<TD>nne</TD>
<TD>~ nner , ~ nnedc</TD>
</TR>

<TR>
<TD>exmidne</TD>
<TD>~ dcne </TD>
</TR>

<TR>
<TD>neor</TD>
<TD>~ pm2.53 , ~ ori , ~ ord </TD>
</TR>

<TR>
<TD>neorian</TD>
<TD>~ pm3.14 </TD>
</TR>

<TR>
<TD>nnel</TD>
<TD><I>none</I></TD>
<TD>The reverse direction could be proved; the forward direction
is double negation elimination.</TD>
</TR>

<TR>
<TD>nfrald</TD>
<TD>~ nfraldxy , ~ nfraldya </TD>
</TR>

<TR>
<TD>rexnal</TD>
<TD>~ rexnalim </TD>
</TR>

<TR>
<TD>rexanali</TD>
<TD><I>none</I></TD>
</TR>

<TR>
<TD>nrexralim</TD>
<TD><I>none</I></TD>
</TR>

<TR>
<TD>dfral2</TD>
<TD>~ ralexim </TD>
</TR>

<TR>
<TD>dfrex2</TD>
<TD>~ rexalim </TD>
</TR>

<TR>
<TD>nfrexd</TD>
<TD>~ nfrexdxy , ~ nfrexdya </TD>
</TR>

<TR>
<TD>nfral</TD>
<TD>~ nfralxy , ~ nfralya </TD>
</TR>

<TR>
<TD>nfra2</TD>
<TD>~ nfra1 , ~ nfralya </TD>
</TR>

<TR>
<TD>nfrex</TD>
<TD>~ nfrexxy , ~ nfrexya </TD>
</TR>

<TR>
<TD>r19.30</TD>
<TD><I>none</I></TD>
</TR>

<TR>
<TD>r19.35</TD>
<TD>~ r19.35-1</TD>
</TR>

<TR>
<TD>ralcom2</TD>
<TD>~ ralcom </TD>
</TR>

<TR>
<TD>sspss</TD>
<TD>~ sspssr </TD>
</TR>

<TR>
<TD>n0f</TD>
<TD>~ n0rf </TD>
</TR>

<TR>
<TD>n0</TD>
<TD>~ n0r </TD>
</TR>

<TR>
<TD>neq0</TD>
<TD>~ neq0r </TD>
</TR>

<TR>
<TD>reximdva0</TD>
<TD>~ reximdva0m </TD>
</TR>

<TR>
<TD>rabn0</TD>
<TD>~ rabn0m , ~ rabn0r </TD>
</TR>

<TR>
<TD>ssdif0</TD>
<TD>~ ssdif0im </TD>
</TR>

<TR>
<TD>inssdif0</TD>
<TD>~ inssdif0im </TD>
</TR>

<TR>
<TD>undif2</TD>
<TD>~ undif2ss </TD>
</TR>

<TR>
<TD>uneqdifeq</TD>
<TD>~ uneqdifeqim </TD>
</TR>

<TR>
<TD>r19.45zv</TD>
<TD>~ r19.45mv </TD>
</TR>

<TR>
<TD>dfif2</TD>
<TD>~ df-if </TD>
</TR>

<TR>
<TD>ifsb</TD>
<TD><I>none</I></TD>
</TR>

<TR>
<TD>dfif4</TD>
<TD><I>none</I></TD>
<TD>Unused in set.mm</TD>
</TR>

<TR>
<TD>dfif5</TD>
<TD><I>none</I></TD>
<TD>Unused in set.mm</TD>
</TR>

<TR>
<TD>ifnot</TD>
<TD><I>none</I></TD>
</TR>

<TR>
<TD>ifan</TD>
<TD><I>none</I></TD>
</TR>

<TR>
<TD>ifor</TD>
<TD><I>none</I></TD>
</TR>

<TR>
<TD>ifeq1da, ifeq2da</TD>
<TD><I>none</I></TD>
</TR>

<TR>
<TD>ifclda</TD>
<TD><I>none</I></TD>
</TR>

<TR>
<TD>ifeqda</TD>
<TD><I>none</I></TD>
</TR>

<TR>
<TD>elimif , ifbothda , ifboth , ifid , eqif , ifval , elif ,
ifel , ifcl , ifcld , ifeqor , 2if2 , ifcomnan , csbif ,
csbifgOLD</TD>
<TD><I>none</I></TD>
</TR>

<TR>
<TD>dedth , dedth2h , dedth3h , dedth4h , dedth2v , dedth3v ,
dedth4v , elimhyp , elimhyp2v , elimhyp3v , elimhyp4v ,
elimel , elimdhyp , keephyp , keephyp2v , keephyp3v , keepel ,
ifex , ifexg</TD>
<TD><I>none</I></TD>
<TD>Even in set.mm, the weak deduction theorem is discouraged in
favor of theorems in deduction form.</TD>
</TR>

<TR>
<TD>iundif2</TD>
<TD>~ iundif2ss </TD>
</TR>

<TR>
<TD>trintss</TD>
<TD>~ trintssm </TD>
</TR>

<TR>
<TD>trint0</TD>
<TD>~ trint0m </TD>
</TR>

<TR>
<TD>csbexg , csbex</TD>
<TD>~ csbexga , ~ csbexa </TD>
<TD>set.mm uses case elimination to remove the ` A e. _V ` condition.</TD>
</TR>

<TR>
<TD>intabs</TD>
<TD><I>none</I></TD>
<TD>Lightly used in set.mm, and the set.mm proof is not intuitionistic</TD>
</TR>

<TR>
<TD>moabex</TD>
<TD>~ euabex </TD>
<TD>In general, most of the set.mm ` E! ` theorems still hold, but a
decent number of the ` E* ` ones get caught up on "there are two cases: the
set exists or it does not"</TD>
</TR>

<TR>
<TD>snex</TD>
<TD>~ snexg , ~ snex </TD>
<TD>The iset.mm version of ~ snex has an additional hypothesis</TD>
</TR>

<TR>
<TD>opex</TD>
<TD>~ opexg , ~ opex </TD>
<TD>The iset.mm version of ~ opex has additional hypotheses</TD>
</TR>

<TR>
<TD>df-so</TD>
<TD>~ df-iso </TD>
<TD>Although we define ` Or ` to describe a weakly linear order (such
as real numbers), there are some orders which are also trichotomous, for
example ~ nntri3or , ~ pitri3or , and ~ nqtri3or .
</TR>

<TR>
<TD ROWSPAN="5">sotric</TD>
<TD>~ sotricim </TD>
<TD>One direction, for any weak linear order.</TD>
</TR>

<TR>
<TD>~ sotritric </TD>
<TD>For a trichotomous order.</TD>
</TR>

<TR>
<TD>~ nntri2 </TD>
<TD>For the specific order ` _E Or _om `</TD>
</TR>

<TR>
<TD>~ pitric </TD>
<TD>For the specific order ` <N Or N. `</TD>
</TR>

<TR>
<TD>~ nqtric </TD>
<TD>For the specific order ` <Q Or Q. `</TD>
</TR>

<TR>
<TD>sotrieq</TD>
<TD>~ sotritrieq </TD>
<TD>For a trichotomous order</TD>
</TR>

<TR>
<TD>sotrieq2</TD>
<TD>see sotrieq and then apply ~ ioran </TD>
</TR>

<TR>
<TD>issoi</TD>
<TD>~ issod , ~ ispod </TD>
<TD>Many of the set.mm usages of issoi don't carry over, so
there is less need for this convenience theorem.</TD>
</TR>

<TR>
<TD>isso2i</TD>
<TD>~ issod </TD>
<TD>Presumably this could be proved if we need it.</TD>
</TR>

<TR>
<TD>df-fr and all theorems using <TT>Fr</TT></TD>
<TD><I>none</I></TD>
<TD><P>Right now iset.mm does not have a well-founded predicate
(<code>Fr</code> in set.mm). This means that various theorems (involving
ordinals, especially) require the
Axiom of Set Induction ~ ax-setind (the IZF equivalent to the Axiom of
Foundation/Regularity in ZF), where the set.mm proofs of those theorems
do not.</P>

<P>Presumably if we were to add <code>Fr</code> we'd define it as being
inductive, that is, a property that satisfies the epsilon (or R)
induction principle is always true. For example:
R Fr A ` <-> A. s ( A. x ( A. y ( y R x -> y e. s ) -> x e. s ) -> A C_ s ) `
</P>

<P>This definition has some problems when A is a proper class. As such,
~ ax-setind has to be stated as a schema instead:
` A. x ( A. y ( y e. x -> y e. S ) -> x e. S ) -> S = _V `
</P>

<P>There are two ways to say no infinite descending sequence, using
` E. -. ` or ` -. A. `, which are not intuitionistically equivalent.
Furthermore there are some trivial commutations that are not
intuitionistically valid. So I think that makes the following definition
possibilities:</P>

<P>R Fr A ` <-> A. s ( A. x ( A. y ( y R x -> y e. s ) -> x e. s ) -> A C_ s ) `</P>
<P>R Fr2 A ` <-> A. s ( s C_ A -> ( A. x e. s E. y e. s y R x -> s = (/) ) ) `</P>
<P>R Fr3 A ` <-> A. s ( s C_ A -> ( E. x x e. s -> E. x e. s A. y e. s -. y R x ) ) `</P>

<P>The set.mm definition is roughly Fr3 (but it uses nonempty in place of
inhabited). We can probably just focus on the first definition, but ideally
we'd prove it in set.mm (to show that given excluded middle it is equivalent
to the definition of Fr in set.mm).</P>

<P>If we adopted well-foundedness along these lines, we'd be able to add
well-foundedness to the definition of an ordinal and prove many of the
ordinal theorems without ~ ax-setind . The proof of ~ ordirr would be
similar to the current proof of ~ elirr except that ~ ax-setind would
be replaced by ` _E ` Fr ` A ` and ` _V ` throughout the ~ elirr proof
would be replaced by ` A ` . Likewise for ~ en2lp . These theorems (for
ordinals) would then not rely on ~ ax-setind .</P>
</TD>
</TR>

<TR>
<TD>df-we (and all theorems using <TT>We</TT>)</TD>
<TD><I>none</I></TD>
<TD>Ordering is moderately different in constructive logic,
so if there is anything along these lines worth doing it
will be different from set.mm.</TD>
</TR>

<TR>
<TD>tz7.7</TD>
<TD><I>none</I></TD>
</TR>

<TR>
<TD>ordelssne</TD>
<TD><I>none</I></TD>
</TR>

<TR>
<TD>ordelpss</TD>
<TD><I>none</I></TD>
</TR>

<TR>
<TD>ordsseleq</TD>
<TD>~ onelss , ~ eqimss </TD>
<TD>Taken together, ~ onelss and ~ eqimss represent the reverse direction of
the biconditional from ordsseleq</TD>
</TR>

<TR>
<TD>ordtri3or</TD>
<TD>~ nntri3or </TD>
<TD>Ordinal trichotomy implies the law of the excluded middle as shown
in ~ ordtriexmid .
</TR>

<TR>
<TD>ordtri2</TD>
<TD>~ nntri2 </TD>
<TD>ordtri2 for all ordinals presumably implies excluded middle although
we don't have a specific proof analogous to ~ ordtriexmid .</TD>
</TR>

<TR>
<TD>ordtri3 , ordtri4 ,
ordtri2or2 , ordtri2or3 , dford2
</TD>
<TD><I>none</I></TD>
<TD>Ordinal trichotomy implies the law of the excluded middle as shown
in ~ ordtriexmid . We don't have similar proofs for every variation of
of trichotomy but most of them are presumably powerful enough to imply
excluded middle.</TD>
</TR>

<TR>
<TD>ordtri1 , ontri1 , onssneli , onssnel2i</TD>
<TD>~ ssnel , ~ nntri1 </TD>
<TD>~ ssnel is a trichotomy-like theorem which does hold, although
it is an implication whereas ordtri1 is a biconditional. ~ nntri1
is biconditional, but just for natural numbers.</TD>
</TR>

<TR>
<TD>ordtr2 , ontr2</TD>
<TD><I>none</I></TD>
<TD>See also ordelpss in set.mm</TD>
</TR>

<TR>
<TD>ordtr3</TD>
<TD><I>none</I></TD>
<TD>This is weak linearity of ordinals, which presumably
implies excluded middle by ~ ordsoexmid .</TD>
</TR>

<TR>
<TD>ordtri2or</TD>
<TD><I>none</I></TD>
<TD>Implies excluded middle as shown at ~ ordtri2orexmid .</TD>
</TR>

<TR>
<TD>ord0eln0 , on0eln0</TD>
<TD>~ ne0i , ~ nn0eln0 </TD>
</TR>

<TR>
<TD>nsuceq0</TD>
<TD>~ nsuceq0g </TD>
</TR>

<TR>
<TD>ordsssuc</TD>
<TD>~ trsucss </TD>
</TR>

<TR>
<TD>ordequn</TD>
<TD><I>none</I></TD>
<TD>If you know which ordinal is larger, you can achieve
a similar result via theorems such as ~ oneluni or ~ ssequn1 .</TD>
</TR>

<TR>
<TD>ordun</TD>
<TD>~ onun2 </TD>
</TR>

<TR>
<TD>dmxpid</TD>
<TD>~ dmxpm </TD>
</TR>

<TR>
<TD>relimasn</TD>
<TD>~ imasng </TD>
</TR>

<TR>
<TD>opswap</TD>
<TD>~ opswapg </TD>
</TR>

<TR>
<TD>cnvso</TD>
<TD>~ cnvsom </TD>
</TR>

<TR>
<TD>iotaex</TD>
<TD>~iotacl , ~ euiotaex </TD>
</TR>

<TR>
<TD>dffun3</TD>
<TD>~ dffun5r</TD>
</TR>

<TR>
<TD>dffun5</TD>
<TD>~ dffun5r</TD>
</TR>

<TR>
<TD ROWSPAN="5">fvex</TD>
<TD>~ funfvex </TD>
<TD>when evaluating a function within its domain</TD>
</TR>

<TR>
<TD>~ fvexg , ~ fvex </TD>
<TD>when the function is a set and is evaluated at a set</TD>
</TR>

<TR>
<TD>~ relrnfvex </TD>
<TD>when evaluating a relation whose range is a set</TD>
</TR>

<TR>
<TD>~ mptfvex </TD>
<TD>when the function is defined via maps-to, yields a set for all inputs,
and is evaluated at a set</TD>
</TR>

<TR>
<TD>~ 1stexg , ~ 2ndexg </TD>
<TD>for the functions ` 1st ` and ` 2nd `</TD>
</TR>

<TR>
<TD>ndmfv</TD>
<TD>~ ndmfvg </TD>
<TD>The ` -. A e. _V ` case is ~ fvprc .</TD>
</TR>

<TR>
<TD>elfvdm</TD>
<TD>~ relelfvdm </TD>
</TR>

<TR>
<TD>elfvex</TD>
<TD>~ relelfvdm </TD>
</TR>

<TR>
<TD>f0cli</TD>
<TD>~ ffvelrn </TD>
</TR>

<TR>
<TD>funiunfv</TD>
<TD>~ fniunfv , ~ funiunfvdm </TD>
</TR>

<TR>
<TD>funiunfvf</TD>
<TD>~ funiunfvdmf </TD>
</TR>

<TR>
<TD>eluniima</TD>
<TD>~ eluniimadm </TD>
</TR>

<TR>
<TD>riotaex</TD>
<TD>~ riotacl , ~ riotaexg</TD>
</TR>

<TR>
<TD>nfriotad</TD>
<TD>~ nfriotadxy </TD>
</TR>

<TR>
<TD>csbriota , csbriotagOLD</TD>
<TD>~ csbriotag </TD>
</TR>

<TR>
<TD>riotaxfrd</TD>
<TD><I>none</I></TD>
<TD>Although it may be intuitionizable, it is lightly used in set.mm.</TD>
</TR>

<TR>
<TD ROWSPAN="4">ovex</TD>
<TD>~ fnovex </TD>
<TD>when the operation is a function evaluated within its domain.</TD>
</TR>

<TR>
<TD>~ fvexg , ~ fvex</TD>
<TD>when the operation is a set and is evaluated at a set</TD>
</TR>

<TR>
<TD>~ relrnfvex</TD>
<TD>when the operation is a relation whose range is a set</TD>
</TR>

<TR>
<TD>~ mpt2fvex </TD>
<TD>When the operation is defined via maps-to, yields a set on
any inputs, and is being evaluated at two sets.</TD>
</TR>

<TR>
<TD>fnov</TD>
<TD>~ fnovim </TD>
</TR>

<TR>
<TD>ov3</TD>
<TD>~ ovi3 </TD>
<TD>Although set.mm's ov3 could be proved, it is only used a few places
in set.mm, and in iset.mm those places need the modified form
found in ~ ovi3 .</TD>
</TR>

<TR>
<TD>oprssdm</TD>
<TD><I>none</I></TD>
</TR>

<TR>
<TD>ndmovg , ndmov</TD>
<TD>~ ndmfvg </TD>
<TD>These theorems are generally used in set.mm for case elimination
which is why we just have the general ~ ndmfvg rather than an
operation-specific version.
</TR>

<TR>
<TD>ndmovcl , ndmovcom , ndmovass , ndmovdistr , ndmovord ,
    and ndmovordi</TD>
<TD><I>none</I></TD>
<TD>These theorems are generally used in set.mm for case elimination
and the most straightforward way to avoid them is to add conditions
that we are evaluating functions within their domains.
</TR>

<TR>
<TD>ndmovrcl</TD>
<TD>~ elmpt2cl , ~ relelfvdm</TD>
</TR>

<TR>
<TD>caov4</TD>
<TD>~ caov4d </TD>
<TD>Note that ~ caov4d has a closure hypothesis.</TD>
</TR>

<TR>
<TD>caov411</TD>
<TD>~ caov411d </TD>
<TD>Note that ~ caov411d has a closure hypothesis.</TD>
</TR>

<TR>
<TD>caov42</TD>
<TD>~ caov42d </TD>
<TD>Note that ~ caov42d has a closure hypothesis.</TD>
</TR>

<TR>
<TD>caovdir</TD>
<TD>~ caovdird </TD>
<TD>~ caovdird adds some constraints about where the operations are evaluated.</TD>
</TR>

<TR>
<TD>caovdilem</TD>
<TD>~ caovdilemd </TD>
</TR>

<TR>
<TD>caovlem2</TD>
<TD>~ caovlem2d </TD>
</TR>

<TR>
<TD>caovmo</TD>
<TD>~ caovimo </TD>
</TR>

<TR>
<TD>ofval</TD>
<TD>~ fnofval </TD>
</TR>

<TR>
<TD>offn , offveq , caofid0l , caofid0r , caofid1 , caofid2</TD>
<TD><I>none</I></TD>
<TD>Assuming we really need to add conditions that the operations
are functions being evaluated within their domains, there would be a
fair bit of intuitionizing.</TD>
</TR>

<TR>
<TD>ordeleqon</TD>
<TD><I>none</I></TD>
</TR>

<TR>
<TD>ssonprc</TD>
<TD><I>none</I></TD>
<TD>not provable (we conjecture), but interesting enough to intuitionize anyway. ` U. A = On -> A e/ V ` is provable, and ` ( B e. On /\ U. A C_ B ) -> A e. V ` is provable. (Why isn't ~ df-pss stated so that the set difference is inhabited? If so, you could prove ` U. A C. On -> A e. V `.)</TD>
</TR>

<TR>
<TD>onint</TD>
<TD><I>none</I></TD>
<TD>Conjectured to not be provable without excluded middle. If you apply onint to a pair you can derive totality of the order.</TD>
</TR>

<TR>
<TD>onint0</TD>
<TD><I>none</I></TD>
<TD>Thought to be "trivially not intuitionistic", and it is not clear if there is an alternate way to state it that is true. If the empty set is in A then of course |^| A = (/), but the converse seems difficult. I don't know so much about the structure of the ordinals without linearity,</TD>
</TR>

<TR>
<TD>onssmin, onminesb, onminsb</TD>
<TD><I>none</I></TD>
<TD>Conjectured to not be provable without excluded middle, for the same reason as onint.</TD>
</TR>

<TR>
<TD>oninton</TD>
<TD><I>none yet</I></TD>
<TD>This one (with non-empty changed to inhabited) I think can still be salvaged though. From the fact that it is inhabited you get that it exists, and is a subset of an ordinal x. It is an intersection of transitive sets so it is transitive, and of course all its members are members of x so they are transitive too. And E. Fr A falls to subsets.</TD>
</TR>

<TR>
<TD>onintrab, onintrab2</TD>
<TD><I>none yet</I></TD>
<TD>The set.mm proof uses oninton.</TD>
</TR>

<TR>
<TD>oneqmin</TD>
<TD><I>none</I></TD>
<TD>Falls as written because it implies onint, but it might be useful to keep the reverse direction for subsets that do have a minimum.</TD>
</TR>

<TR>
<TD>onminex</TD>
<TD><I>none yet</I></TD>
<TD>falls as written because it implies onint, but it might be useful to keep the reverse direction for subsets that do have a minimum.</TD>
</TR>

<TR>
<TD>onmindif2</TD>
<TD><I>none</I></TD>
<TD>Conjectured to not be provable without excluded middle.</TD>
</TR>

<TR>
<TD>onmindif2</TD>
<TD><I>none</I></TD>
<TD>Conjectured to not be provable without excluded middle.</TD>
</TR>

<TR>
<TD>ordpwsuc</TD>
<TD>~ ordpwsucss </TD>
<TD>See the ~ ordpwsucss comment for discussion of the succcessor-like
properites of ` ( ~P A i^i On ) ` .  Full ordpwsuc implies excluded
middle as seen at ~ ordpwsucexmid .</TD>
</TR>

<TR>
<TD>ordsucelsuc</TD>
<TD>~ onsucelsucr , ~ nnsucelsuc </TD>
<TD>The converse of ~ onsucelsucr implies excluded middle, as shown at ~ onsucelsucexmid .</TD>
</TR>

<TR>
<TD>ordsucsssuc</TD>
<TD>~ onsucsssucr , ~ nnsucsssuc </TD>
<TD>The converse of ~ onsucsssucr implies excluded middle, as shown at ~ onsucsssucexmid .</TD>
</TR>

<TR>
<TD>ordsucuniel</TD>
<TD>~ sucunielr</TD>
<TD>Full ordsucuniel implies excluded middle, as shown at ~ ordsucunielexmid .</TD>
</TR>

<TR>
<TD>ordsucun</TD>
<TD><I>none yet</I></TD>
<TD>Conjectured to be provable in the reverse direction, but not the forward direction (implies some order totality).</TD>
</TR>

<TR>
<TD>ordunpr</TD>
<TD><I>none</I></TD>
<TD>Presumably not provable without excluded middle.</TD>
</TR>

<TR>
<TD>ordunel</TD>
<TD><I>none</I></TD>
<TD>Conjectured to not be provable (ordunel implies ordsucun).</TD>
</TR>

<TR>
<TD>onsucuni, ordsucuni</TD>
<TD><I>none</I></TD>
<TD>Conjectured to not be provable without excluded middle.</TD>
</TR>

<TR>
<TD>orduniorsuc</TD>
<TD><I>none</I></TD>
<TD>Presumably not provable.</TD>
</TR>

<TR>
<TD>ordunisuc</TD>
<TD>~ onunisuci , ~ unisuc , ~ unisucg </TD>
</TR>

<TR>
<TD>orduniss2</TD>
<TD>~ onuniss2 </TD>
</TR>

<TR>
<TD>onsucuni2</TD>
<TD><I>none yet</I></TD>
<TD>Conjectured to be provable.</TD>
</TR>

<TR>
<TD>0elsuc</TD>
<TD><I>none yet</I></TD>
<TD>Conjectured to be provable.</TD>
</TR>

<TR>
<TD>onuniorsuci</TD>
<TD><I>none</I></TD>
<TD>Conjectured to not be provable without excluded middle.</TD>
</TR>

<TR>
<TD>onuninsuci, ordununsuc</TD>
<TD><I>none</I></TD>
<TD>Conjectured to be provable in the forward direction but not the reverse one.</TD>
</TR>

<TR>
<TD>onsucssi</TD>
<TD><I>none yet</I></TD>
<TD>Conjectured to be provable.</TD>
</TR>

<TR>
<TD>nlimsucg</TD>
<TD><I>none yet</I></TD>
<TD>Conjectured to be provable.</TD>
</TR>

<TR>
<TD>ordunisuc2</TD>
<TD>~ ordunisuc2r </TD>
<TD><P>The forward direction is conjectured to imply excluded middle. Here is a sketch of the proposed proof.</P>

<P>Let om' be the set of all finite iterations of suc' A = ` ( ~P A i^i On ) ` on ` (/) `. (We can formalize this proof but not until we have om and at least finite induction.) Then om' = U. om' because if x e. om' then x = suc'^n (/) for some n, and then x C_ suc'^n (/) implies x e. suc'^(n+1) (/) e. om' so x e. U. om'.<p>

<P>Now supposing the theorem, we know that A. x e. om' suc x e. om', so in particular 2o e. om', that is, 2o = suc'^n (/) for some n. (Note that 1o = suc' (/) - see ~ pw0 .) For n = 0 and n = 1 this is clearly false, and for n = m+3 we have 1o e. suc' suc' (/) , so 2o C_ suc' suc' (/), so 2o e. suc' suc' suc' (/) C_ suc' suc' suc' suc'^m (/) = 2o, contradicting ordirr.</P>

<P>Thus 2o = suc' suc' (/) = suc' 1o. Applying this to X = ` { x e. { (/) } | ph } ` we have X C_ 1o implies X e. suc' 1o = 2o and hence X = (/) \/ X = 1o, and LEM follows (by ~ ordtriexmidlem2 for ` X = (/) ` and ~ rabsnt as seen in the ~ onsucsssucexmid proof for ` X = 1o ` ).</P>
</TD>
</TR>

<TR>
<TD>ordzsl, onzsl, dflim3, nlimon</TD>
<TD><I>none</I></TD>
</TR>

<TR>
<TD>dflim4</TD>
<TD>~ df-ilim </TD>
<TD>We conjecture that dflim4 is not equivalent to ~ df-ilim .</TD>
</TR>

<TR>
<TD>limsuc</TD>
<TD><I>none yet</I></TD>
<TD>Conjectured to be provable.</TD>
</TR>

<TR>
<TD>limsssuc</TD>
<TD><I>none yet</I></TD>
<TD>Conjectured to be provable.</TD>
</TR>

<TR>
<TD>tfinds</TD>
<TD>~ tfis3 </TD>
</TR>

<TR>
<TD>findsg</TD>
<TD>~ uzind4 </TD>
<TD>findsg presumably could be proved, but there
hasn't been a need for it.</TD>
</TR>

<TR>
<TD>xpexr2</TD>
<TD>~ xpexr2m </TD>
</TR>

<TR>
<TD>1stval</TD>
<TD>~ 1stvalg </TD>
</TR>

<TR>
<TD>2ndval</TD>
<TD>~ 2ndvalg </TD>
</TR>

<TR>
<TD>1stnpr</TD>
<TD><I>none</I></TD>
<TD>May be intuitionizable, but very lightly used in set.mm.</TD>
</TR>

<TR>
<TD>2ndnpr</TD>
<TD><I>none</I></TD>
<TD>May be intuitionizable, but very lightly used in set.mm.</TD>
</TR>

<TR>
<TD>brtpos</TD>
<TD>~ brtposg </TD>
</TR>

<TR>
<TD>ottpos</TD>
<TD>~ ottposg </TD>
</TR>

<TR>
<TD>ovtpos</TD>
<TD>~ ovtposg </TD>
</TR>

<TR>
<TD>pwuninel</TD>
<TD>~ pwuninel2 </TD>
<TD>The set.mm proof of pwuninel uses case elimination.</TD>
</TR>

<TR>
<TD>iunonOLD</TD>
<TD>~ iunon </TD>
</TR>

<TR>
<TD>smofvon2</TD>
<TD>~ smofvon2dm </TD>
</TR>

<TR>
<TD>tfr1</TD>
<TD>~ tfri1 </TD>
</TR>

<TR>
<TD>tfr2</TD>
<TD>~ tfri2 </TD>
</TR>

<TR>
<TD>tfr3</TD>
<TD>~ tfri3 </TD>
</TR>

<TR>
<TD>tfr2b , recsfnon , recsval</TD>
<TD><I>none</I></TD>
<TD>These transfinite recursion theorems are lightly used in set.mm.</TD>
</TR>

<TR>
<TD>df-rdg</TD>
<TD>~ df-irdg</TD>
<TD>This definition combines the successor and limit cases (rather than specifying them as separate cases in a way which relies on excluded middle). In the words of [Crosilla], p. "Set-theoretic principles incompatible with intuitionistic logic", "we can still define many of the familiar set-theoretic operations by transfinite recursion on ordinals (see Aczel and Rathjen 2001, Section 4.2). This is fine as long as the definitions by transfinite recursion do not make case distinctions such as in the classical ordinal cases of successor and limit."</TD>
</TR>

<TR>
<TD>rdgfnon</TD>
<TD>~ rdgifnon </TD>
</TR>

<TR>
<TD>ordge1n0</TD>
<TD>~ ordge1n0im , ~ ordgt0ge1 </TD>
</TR>

<TR>
<TD>ondif1</TD>
<TD>~ dif1o </TD>
<TD>In set.mm, ondif1 is used for Cantor Normal Form</TD>
</TR>

<TR>
<TD>ondif2 , dif20el</TD>
<TD><I>none</I></TD>
<TD>The set.mm proof is not intuitionistic</TD>
</TR>

<TR>
<TD>brwitnlem</TD>
<TD><I>none</I></TD>
<TD>The set.mm proof is not intuitionistic</TD>
</TR>

<TR>
<TD>om0r</TD>
<TD>~ om0 , ~ nnm0r </TD>
</TR>

<TR>
<TD>om00</TD>
<TD>~ nnm00 </TD>
</TR>

<TR>
<TD>om00el</TD>
<TD><I>none</I></TD>
</TR>

<TR>
<TD>suc11reg</TD>
<TD>~ suc11g </TD>
</TR>

<TR>
<TD>frfnom</TD>
<TD>~ frecfnom </TD>
<TD>frecfnom adopts the ` frec ` notation and adds conditions on the
characteristic function and initial value.</TD>
</TR>

<TR>
<TD>fr0g</TD>
<TD>~ frec0g </TD>
<TD>frec0g adopts the ` frec ` notation and adds a condition on the
characteristic function.</TD>
</TR>

<TR>
<TD>frsuc</TD>
<TD>~ frecsuc </TD>
<TD>frecsuc adopts the ` frec ` notation and adds conditions on the
characteristic function and initial value.</TD>
</TR>

<TR>
<TD>om0x</TD>
<TD>~ om0 </TD>
</TR>

<TR>
<TD>oaord1</TD>
<TD><I>none yet</I></TD>
</TR>

<TR>
<TD>oaword</TD>
<TD>~ oawordi </TD>
<TD>The other direction presumably could be proven but isn't yet.</TD>
</TR>

<TR>
<TD>omwordi</TD>
<TD>~ nnmword</TD>
<TD>The set.mm proof of omwordi relies on case elimination.</TD>
</TR>

<TR>
<TD>omword1</TD>
<TD>~ nnmword</TD>
</TR>

<TR>
<TD>nnawordex</TD>
<TD>~ nnaordex </TD>
<TD>nnawordex is only used a few places in set.mm</TD>
</TR>

<TR>
<TD>swoso</TD>
<TD><I>none</I></TD>
<TD>Unused in set.mm.</TD>
</TR>

<TR>
<TD>ecdmn0</TD>
<TD>~ ecdmn0m </TD>
</TR>

<TR>
<TD>erdisj, qsdisj, qsdisj2, uniinqs</TD>
<TD><I>none</I></TD>
<TD>These could presumably be restated to be provable, but they are lightly
used in set.mm</TD>
</TR>

<TR>
<TD>xpider</TD>
<TD>~ xpiderm </TD>
</TR>

<TR>
<TD>iiner</TD>
<TD>~ iinerm </TD>
</TR>

<TR>
<TD>riiner</TD>
<TD>~ riinerm </TD>
</TR>

<TR>
<TD>brecop2</TD>
<TD><I>none</I></TD>
<TD>This is a form of reverse closure and uses excluded
middle in its proof.</TD>
</TR>

<TR>
<TD>erov , erov2</TD>
<TD><I>none</I></TD>
<TD>Unused in set.mm.</TD>
</TR>

<TR>
<TD>eceqoveq</TD>
<TD><I>none</I></TD>
<TD>Unused in set.mm.</TD>
</TR>

<TR>
<TD>df-sdom , relsdom , brsdom , dfdom2 , sdomdom , sdomnen ,
brdom2 , bren2 , domdifsn</TD>
<TD><I>none</I></TD>
<TD>Many aspects of strict dominance as developed in set.mm rely
on excluded middle and a different definition would be needed if
we wanted strict dominance to have the expected properties.</TD>
</TR>

<TR>
<TD>en1b</TD>
<TD>~ en1bg </TD>
</TR>

<TR>
<TD>mapsnen , map1 , pw2f1olem , pw2f1o , pw2eng , pw2en</TD>
<TD><I>none</I></TD>
<TD>We have not added set exponentiation to iset.mm yet.</TD>
</TR>

<TR>
<TD>snfi</TD>
<TD>~ snfig</TD>
</TR>

<TR>
<TD>difsnen</TD>
<TD><I>none</I></TD>
<TD>The set.mm proof uses excluded middle.</TD>
</TR>

<TR>
<TD>undom</TD>
<TD><I>none</I></TD>
<TD>The set.mm proof uses undif2 and we just have ~ undif2ss </TD>
</TR>

<TR>
<TD>xpdom3</TD>
<TD>~ xpdom3m </TD>
</TR>

<TR>
<TD>domunsncan</TD>
<TD><I>none</I></TD>
<TD>The set.mm proof relies on difsnen</TD>
</TR>

<TR>
<TD>omxpenlem , omxpen , omf1o</TD>
<TD><I>none</I></TD>
<TD>The set.mm proof relies on omwordi</TD>
</TR>

<TR>
<TD>enfixsn</TD>
<TD><I>none</I></TD>
<TD>The set.mm proof relies on difsnen</TD>
</TR>

<TR>
<TD>sbth and its lemmas, sbthb , sbthcl</TD>
<TD><I>none</I></TD>
<TD>The Schroeder-Bernstein Theorem implies excluded middle</TD>
</TR>

<TR>
<TD>2pwuninel</TD>
<TD>~ 2pwuninelg</TD>
</TR>

<TR>
<TD>onomeneq , onfin , onfin2</TD>
<TD><I>none</I></TD>
<TD>The set.mm proofs rely on excluded middle</TD>
</TR>

<TR>
<TD>nndomo</TD>
<TD><I>none</I></TD>
<TD>Should be provable but the set.mm proof wouldn't work</TD>
</TR>

<TR>
<TD>nnsdomo , sucdom2 , sucdom , 0sdom1dom , 1sdom2 , sdom1</TD>
<TD><I>none</I></TD>
<TD>iset.mm doesn't yet have strict dominance</TD>
</TR>

<TR>
<TD>modom , modom2</TD>
<TD><I>none</I></TD>
<TD>The set.mm proofs rely on excluded middle</TD>
</TR>

<TR>
<TD>1sdom , unxpdom , unxpdom2 , sucxpdom</TD>
<TD><I>none</I></TD>
<TD>iset.mm doesn't yet have strict dominance</TD>
</TR>

<TR>
<TD>pssinf</TD>
<TD><I>none</I></TD>
<TD>The set.mm proof relies on sdomnen</TD>
</TR>

<TR>
<TD>fisseneq</TD>
<TD><I>none</I></TD>
<TD>The set.mm proof relies on excluded middle</TD>
</TR>

<TR>
<TD>ominf</TD>
<TD><I>none</I></TD>
<TD>Although this theorem presumably could be proved, it would
probably need a very different proof than the set.mm one</TD>
</TR>

<TR>
<TD>isinf</TD>
<TD><I>none</I></TD>
<TD>The set.mm proof uses the converse of ~ ssdif0im</TD>
</TR>

<TR>
<TD>fineqv</TD>
<TD><I>none</I></TD>
<TD>The set.mm proof relies on theorems we don't have, and even
for the theorems we do have, we'd need to carefully look at
what axioms they rely on.</TD>
</TR>

<TR>
<TD>pssnn</TD>
<TD><I>none</I></TD>
<TD>The set.mm proof uses excluded middle.</TD>
</TR>

<TR>
<TD>ssnnfi</TD>
<TD><I>none</I></TD>
<TD>The proof in ~ ssfiexmid would apply to this as well as to
ssfi , since ` { (/) } e. _om `</TD>
</TR>

<TR>
<TD>ssfi</TD>
<TD>~ ssfiexmid</TD>
</TR>

<TR>
<TD>domfi</TD>
<TD><I>none</I></TD>
<TD>The set.mm proof is in terms of ssfi</TD>
</TR>

<TR>
<TD>xpfir</TD>
<TD><I>none</I></TD>
<TD>Nonempty would need to be changed to inhabited, but the
set.mm proof also uses domfi</TD>
</TR>

<TR>
<TD>infi</TD>
<TD><I>none</I></TD>
<TD>Presumably the proof of ~ ssfiexmid could be adapted to show
this implies excluded middle</TD>
</TR>

<TR>
<TD>rabfi</TD>
<TD><I>none</I></TD>
<TD>Presumably the proof of ~ ssfiexmid could be adapted to show
this implies excluded middle</TD>
</TR>

<TR>
<TD>finresfin</TD>
<TD><I>none</I></TD>
<TD>The set.mm proof is in terms of ssfi</TD>
</TR>

<TR>
<TD>f1finf1o</TD>
<TD><I>none</I></TD>
<TD>The set.mm proof is not intuitionistic</TD>
</TR>

<TR>
<TD>nfielex</TD>
<TD><I>none</I></TD>
<TD>The set.mm proof relies on neq0</TD>
</TR>

<TR>
<TD>en1eqsn , en1eqsnbi</TD>
<TD><I>none</I></TD>
<TD>The set.mm proof relies on fisseneq</TD>
</TR>

<TR>
<TD>diffi</TD>
<TD><I>none</I></TD>
<TD>The set.mm proof is in terms of ssfi</TD>
</TR>

<TR>
<TD>dif1en</TD>
<TD><I>none</I></TD>
<TD>The set.mm proof relies on diffi</TD>
</TR>


<TR>
<TD>ax-reg , axreg2 , zfregcl</TD>
<TD>~ ax-setind </TD>
<TD>ax-reg implies excluded middle as seen at ~ regexmid</TD>
</TR>

<TR>
<TD>addcompi</TD>
<TD>~ addcompig </TD>
</TR>

<TR>
<TD>addasspi</TD>
<TD>~ addasspig </TD>
</TR>

<TR>
<TD>mulcompi</TD>
<TD>~ mulcompig </TD>
</TR>

<TR>
<TD>mulasspi</TD>
<TD>~ mulasspig </TD>
</TR>

<TR>
<TD>distrpi</TD>
<TD>~ distrpig </TD>
</TR>

<TR>
<TD>addcanpi</TD>
<TD>~ addcanpig </TD>
</TR>

<TR>
<TD>mulcanpi</TD>
<TD>~ mulcanpig </TD>
</TR>

<TR>
<TD>addnidpi</TD>
<TD>~ addnidpig </TD>
</TR>

<TR>
<TD>ltapi</TD>
<TD>~ ltapig </TD>
</TR>

<TR>
<TD>ltmpi</TD>
<TD>~ ltmpig </TD>
</TR>

<TR>
<TD>nlt1pi</TD>
<TD>~ nlt1pig </TD>
</TR>

<TR>
<TD>df-nq</TD>
<TD>~ df-nqqs </TD>
</TR>

<TR>
<TD>df-nq</TD>
<TD>~ df-nqqs </TD>
</TR>

<TR>
<TD>df-erq</TD>
<TD><I>none</I></TD>
<TD>Not needed given ~ df-nqqs </TD>
</TR>

<TR>
<TD>df-plq</TD>
<TD>~ df-plqqs </TD>
</TR>

<TR>
<TD>df-mq</TD>
<TD>~ df-mqqs </TD>
</TR>

<TR>
<TD>df-1nq</TD>
<TD>~ df-1nqqs </TD>
</TR>

<TR>
<TD>df-ltnq</TD>
<TD>~ df-ltnqqs </TD>
</TR>

<TR>
<TD>elpqn</TD>
<TD><I>none</I></TD>
<TD>Not needed given ~ df-nqqs </TD>
</TR>

<TR>
<TD>ordpipq</TD>
<TD>~ ordpipqqs </TD>
</TR>

<TR>
<TD>addnqf</TD>
<TD>~ dmaddpq , ~ addclnq </TD>
<TD>It should be possible to prove that ` +Q ` is a function, but
so far there hasn't been a need to do so.</TD>
</TR>

<TR>
<TD>addcomnq</TD>
<TD>~ addcomnqg </TD>
</TR>

<TR>
<TD>mulcomnq</TD>
<TD>~ mulcomnqg </TD>
</TR>

<TR>
<TD>mulassnq</TD>
<TD>~ mulassnqg </TD>
</TR>

<TR>
<TD>recmulnq</TD>
<TD>~ recmulnqg </TD>
</TR>

<TR>
<TD>ltanq</TD>
<TD>~ ltanqg </TD>
</TR>

<TR>
<TD>ltmnq</TD>
<TD>~ ltmnqg </TD>
</TR>

<TR>
<TD>ltexnq</TD>
<TD>~ ltexnqq </TD>
</TR>

<TR>
<TD>archnq</TD>
<TD>~ archnqq </TD>
</TR>

<TR>
<TD>df-np</TD>
<TD>~ df-inp </TD>
</TR>

<TR>
<TD>df-1p</TD>
<TD>~ df-i1p </TD>
</TR>

<TR>
<TD>df-plp</TD>
<TD>~ df-iplp </TD>
</TR>

<TR>
<TD>df-ltp</TD>
<TD>~ df-iltp </TD>
</TR>

<TR>
<TD>elnp , elnpi</TD>
<TD>~ elinp </TD>
</TR>

<TR>
<TD>prn0</TD>
<TD>~ prml , ~ prmu </TD>
</TR>

<TR>
<TD>prpssnq</TD>
<TD>~ prssnql , ~ prssnqu </TD>
</TR>

<TR>
<TD>elprnq</TD>
<TD>~ elprnql , ~ elprnqu </TD>
</TR>

<TR>
<TD>prcdnq</TD>
<TD>~ prcdnql , ~ prcunqu </TD>
</TR>

<TR>
<TD>prub</TD>
<TD>~ prubl </TD>
</TR>

<TR>
<TD>prnmax</TD>
<TD>~ prnmaxl </TD>
</TR>

<TR>
<TD>npomex</TD>
<TD><I>none</I></TD>
</TR>

<TR>
<TD>prnmadd</TD>
<TD>~ prnmaddl </TD>
</TR>

<TR>
<TD>genpv</TD>
<TD>~ genipv </TD>
</TR>

<TR>
<TD>genpcd</TD>
<TD>~ genpcdl </TD>
</TR>

<TR>
<TD>genpnmax</TD>
<TD>~ genprndl</TD>
</TR>

<TR>
<TD>ltrnq</TD>
<TD>~ltrnqg , ~ ltrnqi </TD>
</TR>

<TR>
<TD>genpcl</TD>
<TD>~ addclpr , ~ mulclpr </TD>
</TR>

<TR>
<TD>genpass</TD>
<TD>~ genpassg </TD>
</TR>

<TR>
<TD>addclprlem1</TD>
<TD>~ addnqprllem , ~ addnqprulem </TD>
</TR>

<TR>
<TD>addclprlem2</TD>
<TD>~ addnqprl , ~ addnqpru </TD>
</TR>

<TR>
<TD>plpv</TD>
<TD>~ plpvlu </TD>
</TR>

<TR>
<TD>mpv</TD>
<TD>~ mpvlu </TD>
</TR>

<TR>
<TD>mulclprlem</TD>
<TD>~ mulnqprl , ~ mulnqpru </TD>
</TR>

<TR>
<TD>addcompr</TD>
<TD>~ addcomprg </TD>
</TR>

<TR>
<TD>addasspr</TD>
<TD>~ addassprg </TD>
</TR>

<TR>
<TD>mulcompr</TD>
<TD>~ mulcomprg </TD>
</TR>

<TR>
<TD>mulasspr</TD>
<TD>~ mulassprg </TD>
</TR>

<TR>
<TD>distrlem1pr</TD>
<TD>~ distrlem1prl , ~ distrlem1pru </TD>
</TR>

<TR>
<TD>distrlem4pr</TD>
<TD>~ distrlem4prl , ~ distrlem4pru </TD>
</TR>

<TR>
<TD>distrlem5pr</TD>
<TD>~ distrlem5prl , ~ distrlem5pru </TD>
</TR>

<TR>
<TD>distrpr</TD>
<TD>~ distrprg </TD>
</TR>

<TR>
<TD>ltprord</TD>
<TD>~ ltprordil </TD>
<TD>There hasn't yet been a need to investigate versions which are
biconditional or which involve proper subsets.</TD>
</TR>

<TR>
<TD>psslinpr</TD>
<TD>~ ltsopr </TD>
</TR>

<TR>
<TD>prlem934</TD>
<TD>~ prarloc2 </TD>
</TR>

<TR>
<TD>ltaddpr2</TD>
<TD>~ ltaddpr </TD>
</TR>

<TR>
<TD>ltexprlem1 , ltexprlem2 , ltexprlem3 , ltexprlem4</TD>
<TD><I>none</I></TD>
<TD>See the lemmas for ~ ltexpri generally.</TD>
</TR>

<TR>
<TD>ltexprlem5</TD>
<TD>~ ltexprlempr </TD>
</TR>

<TR>
<TD>ltexprlem6</TD>
<TD>~ ltexprlemfl , ~ ltexprlemfu </TD>
</TR>

<TR>
<TD>ltexprlem7</TD>
<TD>~ ltexprlemrl , ~ ltexprlemru </TD>
</TR>

<TR>
<TD>ltapr</TD>
<TD>~ ltaprg </TD>
</TR>

<TR>
<TD>addcanpr</TD>
<TD>~ addcanprg </TD>
</TR>

<TR>
<TD>prlem936</TD>
<TD>~ prmuloc2 </TD>
</TR>

<TR>
<TD>reclem2pr</TD>
<TD>~ recexprlempr </TD>
</TR>

<TR>
<TD>reclem3pr</TD>
<TD>~ recexprlem1ssl , ~ recexprlem1ssu </TD>
</TR>

<TR>
<TD>reclem4pr</TD>
<TD>~ recexprlemss1l , ~ recexprlemss1u , ~ recexprlemex </TD>
</TR>

<TR>
<TD>supexpr , suplem1pr , suplem2pr</TD>
<TD><I>none</I></TD>
<TD>The Least Upper Bound property for sets of real numbers does not hold,
in general, without excluded middle.</TD>
</TR>

<TR>
<TD>mulcmpblnrlem</TD>
<TD>~ mulcmpblnrlemg </TD>
</TR>

<TR>
<TD>ltsrpr</TD>
<TD>~ ltsrprg </TD>
</TR>

<TR>
<TD>dmaddsr , dmmulsr</TD>
<TD><I>none</I></TD>
<TD>Although these presumably could be proved in a way similar
to ~ dmaddpq and ~dmmulpq (in fact ~ dmaddpqlem would seem to
be easily generalizable to anything of the form
` ( ( S X. T ) /. R ) ` ), we haven't yet had a need to do so.
</TR>

<TR>
<TD>addcomsr</TD>
<TD>~ addcomsrg </TD>
</TR>

<TR>
<TD>addasssr</TD>
<TD>~ addasssrg </TD>
</TR>

<TR>
<TD>mulcomsr</TD>
<TD>~ mulcomsrg </TD>
</TR>

<TR>
<TD>mulasssr</TD>
<TD>~ mulasssrg </TD>
</TR>

<TR>
<TD>distrsr</TD>
<TD>~ distrsrg </TD>
</TR>

<TR>
<TD>ltasr</TD>
<TD>~ ltasrg </TD>
</TR>

<TR>
<TD>sqgt0sr</TD>
<TD>~ mulgt0sr , ~ apsqgt0 </TD>
</TR>

<TR>
<TD>recexsr</TD>
<TD>~ recexsrlem </TD>
<TD>This would follow from sqgt0sr (as in the set.mm proof of recexsr),
but "not equal to zero" would need to be changed to
"apart from zero".</TD>
</TR>

<TR>
<TD>mappsrpr , ltpsrpr , map2psrpr</TD>
<TD><I>none</I></TD>
<TD>Although variants of these theorems could be intuitionized, in
set.mm they are only used for supremum theorems, so we can consider
this in more detail when we tackle what kind of supremum theorems
to prove.</TD>
</TR>

<TR>
<TD>supsrlem , supsr</TD>
<TD><I>none</I></TD>
<TD>The Least Upper Bound property for sets of real numbers does not hold,
in general, without excluded middle.</TD>
</TR>

<TR>
<TD>axaddf , ax-addf , axmulf , ax-mulf</TD>
<TD><I>none</I></TD>
<TD>Because these are described as deprecated in set.mm, we haven't
figured out what would be involved in proving them for iset.mm.</TD>
</TR>

<TR>
<TD>ax1ne0 , ax-1ne0</TD>
<TD>~ ax0lt1 , ~ ax-0lt1 , ~ 1ap0 , ~ 1ne0 </TD>
</TR>

<TR>
<TD>axrrecex , ax-rrecex</TD>
<TD>~ axprecex , ~ ax-precex </TD>
</TR>

<TR>
<TD>axpre-lttri , ax-pre-lttri</TD>
<TD>~ axpre-ltirr , ~ axpre-ltwlin , ~ ax-pre-ltirr , ~ ax-pre-ltwlin </TD>
</TR>

<TR>
<TD>axpre-sup , ax-pre-sup , axsup</TD>
<TD><I>none yet</I></TD>
<TD>The Least Upper Bound property for sets of real numbers does not hold,
in general, without excluded middle. If we want a set of axioms for real
numbers which allows us to avoid construction-dependent theorems beyond
this point, we'll need a modified Least Upper Bound property, a statement
concerning Dedekind cuts or something similar, or some other axiom(s).</TD>
</TR>

<TR>
<TD>elimne0</TD>
<TD><I>none</I></TD>
<TD>Even in set.mm, the weak deduction theorem is discouraged in
favor of theorems in deduction form.</TD>
</TR>

<TR>
<TD>xrltnle</TD>
<TD>~ xrlenlt </TD>
</TR>

<TR>
<TD>ssxr</TD>
<TD>~ df-xr </TD>
<TD>Lightly used in set.mm</TD>
</TR>

<TR>
<TD>ltnle , ltnlei , ltnled</TD>
<TD>~ lenlt , ~ zltnle </TD>
</TR>

<TR>
<TD>lttri2 , lttri4</TD>
<TD>~ ztri3or </TD>
<TD>Real number trichotomy is not provable.</TD>
</TR>

<TR>
<TD>leloe , eqlelt , leloei , leloed , eqleltd</TD>
<TD><I>none</I></TD>
</TR>

<TR>
<TD>leltne , leltned</TD>
<TD><I>none</I></TD>
</TR>

<TR>
<TD>ltneOLD</TD>
<TD>~ ltne </TD>
</TR>

<TR>
<TD>letric , letrii , letrid</TD>
<TD>~ zletric </TD>
</TR>

<TR>
<TD>ltlen , ltleni , ltlend</TD>
<TD>~ ltleap , ~ zltlen </TD>
</TR>

<TR>
<TD>ne0gt0</TD>
<TD><I>none</I></TD>
<TD>We presumably could prove this if we changed "not equal to zero"
to "apart from zero".</TD>
</TR>

<TR>
<TD>lecasei , ltlecasei</TD>
<TD><I>none</I></TD>
<TD>These are real number trichotomy</TD>
</TR>

<TR>
<TD>lelttric</TD>
<TD>~ zlelttric </TD>
</TR>

<TR>
<TD>lttri2i</TD>
<TD><I>none</I></TD>
<TD>This can be read as "two real numbers are non-equal if and
only if they are apart" which relies on excluded middle</TD>
</TR>

<TR>
<TD>ne0gt0d , lttrid , lttri2d , lttri4d</TD>
<TD><I>none</I></TD>
<TD>These are real number trichotomy</TD>
</TR>

<TR>
<TD>dedekind , dedekindle</TD>
<TD><I>none</I></TD>
</TR>

<TR>
<TD>mul02lem1</TD>
<TD><I>none</I></TD>
<TD>The one use in set.mm is not needed in iset.mm.</TD>
</TR>

<TR>
<TD>negex</TD>
<TD>~ negcl </TD>
</TR>

<TR>
<TD>msqgt0 , msqgt0i , msqgt0d</TD>
<TD>~ apsqgt0 </TD>
<TD>"Not equal to zero" is changed to "apart from zero"</TD>
</TR>

<TR>
<TD>relin01</TD>
<TD><I>none</I></TD>
<TD>Relies on real number trichotomy.</TD>
</TR>

<TR>
<TD>ltordlem , ltord1 , leord1 , eqord1 , ltord2 , leord2 , eqord2</TD>
<TD><I>none</I></TD>
<TD>These depend on real number trichotomy and are not used until
later in set.mm.</TD>
</TR>

<TR>
<TD>wloglei , wlogle</TD>
<TD><I>none</I></TD>
<TD>These depend on real number trichotomy and are not used until
later in set.mm.</TD>
</TR>

<TR>
<TD>recex</TD>
<TD>~ recexap </TD>
<TD>In theorems involving reciprocals or division, not equal to
zero changes to apart from zero.</TD>
</TR>

<TR>
<TD>mulcand, mulcan2d</TD>
<TD>~ mulcanapd , ~ mulcanap2d </TD>
<TD>In theorems involving reciprocals or division, not equal to
zero changes to apart from zero.</TD>
</TR>

<TR>
<TD>mulcanad , mulcan2ad</TD>
<TD>~ mulcanapad , ~ mulcanap2ad</TD>
<TD>In theorems involving reciprocals or division, not equal to
zero changes to apart from zero.</TD>
</TR>

<TR>
<TD>mulcan , mulcan2 , mulcani</TD>
<TD>~ mulcanap , ~ mulcanap2 , ~ mulcanapi </TD>
<TD>In theorems involving reciprocals or division, not equal to
zero changes to apart from zero.</TD>
</TR>

<TR>
<TD>mul0or , mul0ori , mul0ord</TD>
<TD><I>none</I></TD>
<TD>Remark 2.19 of [Geuvers] says that this does not hold in
general and has a counterexample.</TD>
</TR>

<TR>
<TD>mulne0b , mulne0bd , mulne0bad , mulne0bbd</TD>
<TD>~ mulap0b , ~ mulap0bd , ~ mulap0bad , ~ mulap0bbd </TD>
</TR>

<TR>
<TD>mulne0 , mulne0i , mulne0d</TD>
<TD>~ mulap0 , ~ mulap0i , ~ mulap0d </TD>
</TR>

<TR>
<TD>receu</TD>
<TD>~ receuap </TD>
<TD>In theorems involving reciprocals or division, not equal to
zero changes to apart from zero.</TD>
</TR>

<TR>
<TD>mulnzcnopr</TD>
<TD><I>none</I></TD>
</TR>

<TR>
<TD>msq0i , msq0d</TD>
<TD><I>none</I></TD>
<TD>This probably could be proved in terms of tightness of apartness
and ` A # 0 /\ B # 0 -> ( A x. B ) # 0 `, but is unused in set.mm.</TD>
</TR>

<TR>
<TD>mulcan1g , mulcan2g</TD>
<TD><I>various cancellation theorems</I></TD>
<TD>Presumably this is unavailable for the same reason that mul0or
is unavailable.</TD>
</TR>

<TR>
<TD>1div0</TD>
<TD><I>none</I></TD>
<TD>This could be proved, but the set.mm proof does not work as-is.</TD>
</TR>

<TR>
<TD>divval</TD>
<TD>~ divvalap </TD>
<TD>In theorems involving reciprocals or division, not equal to
zero changes to apart from zero.</TD>
</TR>

<TR>
<TD>divmul , divmul2 , divmul3</TD>
<TD>~ divmulap , ~ divmulap2 , divmulap3 </TD>
<TD>In theorems involving reciprocals or division, not equal to
zero changes to apart from zero.</TD>
</TR>

<TR>
<TD>divcl , reccl</TD>
<TD>~ divclap , ~ recclap </TD>
<TD>In theorems involving reciprocals or division, not equal to
zero changes to apart from zero.</TD>
</TR>

<TR>
<TD>divcan1 , divcan2</TD>
<TD>~ divcanap1 , ~ divcanap2 </TD>
<TD>In theorems involving reciprocals or division, not equal to
zero changes to apart from zero.</TD>
</TR>

<TR>
<TD>diveq0</TD>
<TD>~ diveqap0 </TD>
<TD>In theorems involving reciprocals or division, not equal to
zero changes to apart from zero.</TD>
</TR>

<TR>
<TD>divne0b , divne0</TD>
<TD>~ divap0b , ~ divap0 </TD>
</TR>

<TR>
<TD>recne0</TD>
<TD>~ recap0 </TD>
</TR>

<TR>
<TD>recid , recid2</TD>
<TD>~ recidap , ~ recidap2 </TD>
</TR>

<TR>
<TD>divrec</TD>
<TD>~ divrecap </TD>
</TR>

<TR>
<TD>divrec2</TD>
<TD>~ divrecap2  </TD>
</TR>

<TR>
<TD>divass</TD>
<TD>~ divassap </TD>
</TR>

<TR>
<TD>div23 , div32 , div13 , div12</TD>
<TD>~ div23ap , ~ div32ap , ~ div13ap , ~ div12ap </TD>
</TR>

<TR>
<TD>divdir , divcan3 , divcan4</TD>
<TD>~ divdirap , ~ divcanap3 , ~ divcanap4 </TD>
</TR>

<TR>
<TD>div11 , divid , div0</TD>
<TD>~ div11ap , ~ dividap , ~ div0ap </TD>
</TR>

<TR>
<TD>diveq1 , divneg , divsubdir</TD>
<TD>~ diveqap1 , ~ divnegap , ~ divsubdirap </TD>
</TR>

<TR>
<TD>recrec , rec11 , rec11r</TD>
<TD>~ recrecap , ~ rec11ap , ~ rec11rap </TD>
</TR>

<TR>
<TD>divmuldiv , divdivdiv , divcan5</TD>
<TD>~ divmuldivap , ~ divdivdivap , ~ divcanap5 </TD>
</TR>

<TR>
<TD>divmul13 , divmul24 , divmuleq</TD>
<TD>~ divmul13ap , ~ divmul24ap , ~ divmuleqap </TD>
</TR>

<TR>
<TD>recdiv , divcan6 , divdiv32 , divcan7</TD>
<TD>~ recdivap , ~ divcanap6 , ~ divdiv32ap , ~ divcanap7 </TD>
</TR>

<TR>
<TD>dmdcan , divdiv1 , divdiv2 , recdiv2</TD>
<TD>~ dmdcanap , ~ divdivap1 , ~ divdivap2 , ~ recdivap2 </TD>
</TR>

<TR>
<TD>ddcan , divadddiv , divsubdiv</TD>
<TD>~ ddcanap , ~ divadddivap , ~ divsubdivap </TD>
</TR>

<TR>
<TD>ddcan , divadddiv , divsubdiv</TD>
<TD>~ ddcanap , ~ divadddivap , ~ divsubdivap </TD>
</TR>

<TR>
<TD>conjmul , rereccl, redivcl</TD>
<TD>~ conjmulap , ~ rerecclap , ~ redivclap </TD>
</TR>

<TR>
<TD>div2neg , divneg2</TD>
<TD>~ div2negap , ~ divneg2ap </TD>
</TR>

<TR>
<TD>recclzi , recne0zi , recidzi</TD>
<TD>~ recclapzi , ~ recap0apzi , ~ recidapzi </TD>
</TR>

<TR>
<TD>reccli , recidi , recreci</TD>
<TD>~ recclapi , ~ recidapi , ~ recrecapi </TD>
</TR>

<TR>
<TD>dividi , div0i</TD>
<TD>~ dividapi , ~ div0api </TD>
</TR>

<TR>
<TD>divclzi , divcan1zi , divcan2zi</TD>
<TD>~ divclapzi , ~ divcanap1zi , ~ divcanap2zi </TD>
</TR>

<TR>
<TD>divreczi , divcan3zi , divcan4zi</TD>
<TD>~ divrecapzi , ~ divcanap3zi , ~ divcanap4zi </TD>
</TR>

<TR>
<TD>rec11i , rec11ii</TD>
<TD>~ rec11api , ~ rec11apii </TD>
</TR>

<TR>
<TD>divcli , divcan2i , divcan1i , divreci ,
divcan3i , divcan4i </TD>
<TD>~ divclapi , ~ divcanap2i , ~ divcanap1i , ~ divrecapi ,
~ divcanap3i , ~ divcanap4i </TD>
</TR>

<TR>
<TD>div0i</TD>
<TD>~ divap0i </TD>
</TR>

<TR>
<TD>divasszi , divmulzi , divdirzi , divdiv23zi</TD>
<TD>~ divassapzi , ~ divmulapzi , ~ divdirapzi , ~ divdiv23apzi </TD>
</TR>

<TR>
<TD>divmuli , divdiv32i</TD>
<TD>~ divmulapi , ~ divdiv32api </TD>
</TR>

<TR>
<TD>divassi , divdiri , div23i , div11i </TD>
<TD>~ divassapi , ~ divdirapi , ~ div23api , ~ div11api </TD>
</TR>

<TR>
<TD>divmuldivi, divmul13i, divadddivi, divdivdivi</TD>
<TD>~ divmuldivapi , ~ divmul13api , ~ divadddivapi , ~ divdivdivapi </TD>
</TR>

<TR>
<TD>rerecclzi , rereccli , redivclzi , redivcli</TD>
<TD>~ rerecclapzi , ~ rerecclapi , ~ redivclapzi , ~ redivclapi </TD>
</TR>

<TR>
<TD>reccld , rec0d , recidd , recid2d , recrecd ,
dividd , div0d</TD>
<TD>~ recclapd , ~ recap0d , ~ recidapd , ~ recidap2d , ~ recrecapd ,
~ dividapd , ~ div0apd </TD>
</TR>

<TR>
<TD>divcld , divcan1d , divcan2d , divrecd , divrec2d ,
divcan3d , divcan4d</TD>
<TD>~ divclapd , ~ divcanap1d , ~ divcanap2d , ~ divrecapd , ~ divrecap2d ,
~ divcanap3d , ~ divcanap4d </TD>
</TR>

<TR>
<TD>diveq0d , diveq1d , diveq1ad , diveq0ad , divne1d , div0bd , divnegd ,
divneg2d , div2negd</TD>
<TD>~ diveqap0d , ~ diveqap1d , ~ diveqap1ad , ~ diveqap0ad , ~ divap1d ,
~ divap0bd , ~ divnegapd , ~ divneg2apd , ~ div2negapd </TD>
</TR>

<TR>
<TD>divne0d , recdivd , recdiv2d , divcan6d , ddcand , rec11d</TD>
<TD>~ divap0d , ~ recdivapd , ~ recdivap2d , ~ divcanap6d , ~ ddcanapd ,
~ rec11apd </TD>
</TR>

<TR>
<TD>divmuld , div32d , div13d , divdiv32d , divcan5d , divcan5rd ,
divcan7d , dmdcand , dmdcan2d , divdiv1d , divdiv2d</TD>
<TD>~ divmulapd , ~ div32apd , ~ div13apd , ~ divdiv32apd , ~ divcanap5d ,
~ divcanap5rd , ~ divcanap7d , ~ dmdcanapd , ~ dmdcanap2d , ~ divdivap1d ,
~ divdivap2d </TD>
</TR>

<TR>
<TD>divmul2d, divmul3d, divassd, div12d, div23d,
divdird, divsubdird, div11d</TD>
<TD>~ divmulap2d , ~ divmulap3d , ~ divassapd , ~ div12apd , ~ div23apd ,
~ divdirapd , ~ divsubdirapd , ~ div11apd </TD>
</TR>

<TR>
<TD>rereccld , redivcld</TD>
<TD>~ rerecclapd , ~ redivclapd </TD>
</TR>

<TR>
<TD>mvllmuld</TD>
<TD>~ mvllmulapd</TD>
</TR>

<TR>
<TD>elimgt0 , elimge0</TD>
<TD><I>none</I></TD>
<TD>Even in set.mm, the weak deduction theorem is discouraged in
favor of theorems in deduction form.</TD>
</TR>

<TR>
<TD>mulge0b , mulle0b , mulsuble0b</TD>
<TD><I>none</I></TD>
<TD>Presumably unprovable for reasons analogous to mul0or.</TD>
</TR>

<TR>
<TD>ledivp1i , ltdivp1i</TD>
<TD><I>none</I></TD>
<TD>Presumably could be proved, but unused in set.mm.</TD>
</TR>

<TR>
<TD>crne0</TD>
<TD>~ crap0 </TD>
</TR>

<TR>
<TD>ofsubeq0 , ofnegsub , ofsubge0</TD>
<TD><I>none</I></TD>
<TD>Depend on ofval and/or offn .</TD>
</TR>

<TR>
<TD>df-nn</TD>
<TD>~ dfnn2 </TD>
</TR>

<TR>
<TD>dfnn3</TD>
<TD>~ dfnn2 </TD>
<TD>Presumably could be proved, as it is a slight variation of dfnn2</TD>
</TR>

<TR>
<TD>avgle</TD>
<TD><I>none</I></TD>
</TR>

<TR>
<TD>nnunb</TD>
<TD><I>none</I></TD>
<TD>Presumably provable from ~ arch but unused in set.mm.</TD>
</TR>

<TR>
<TD>frnnn0supp , frnnn0fsupp</TD>
<TD>~ nn0supp </TD>
<TD>iset.mm does not yet have either the notation, or in some
cases the theorems, related to the support of a function or
a fintely supported function.</TD>
</TR>

<TR>
<TD>suprzcl</TD>
<TD><I>none</I></TD>
</TR>

<TR>
<TD>zriotaneg</TD>
<TD><I>none</I></TD>
<TD>Lightly used in set.mm</TD>
</TR>

<TR>
<TD>suprfinzcl</TD>
<TD><I>none</I></TD>
</TR>

<TR>
<TD>decex</TD>
<TD>~ deccl </TD>
</TR>

<TR>
<TD>uzwo , uzwo2 , nnwo , nnwof , nnwos</TD>
<TD><I>none</I></TD>
<TD>Presumably would imply excluded middle, unless there is something
which makes this different from ~ nnregexmid .</TD>
</TR>

<TR>
<TD>uzinfmi , nninfm , nn0infm , infmssuzle , infmssuzcl</TD>
<TD><I>none</I></TD>
<TD>We do not yet have a supremum notation, or most supremum theorems,
in iset.mm</TD>
</TR>

<TR>
<TD>negn0</TD>
<TD>~ negm </TD>
</TR>

<TR>
<TD>supminf</TD>
<TD><I>none</I></TD>
<TD>We do not yet have a supremum notation, or most supremum theorems,
in iset.mm</TD>
</TR>

<TR>
<TD>zsupss , suprzcl2 , suprzub , uzsupss</TD>
<TD><I>none</I></TD>
<TD>We do not yet have a supremum notation, or most supremum theorems,
in iset.mm</TD>
</TR>

<TR>
<TD>rpneg</TD>
<TD>~ rpnegap </TD>
</TR>

<TR>
<TD>xrlttri , xrlttri2</TD>
<TD><I>none</I></TD>
<TD>A generalization of real trichotomy.</TD>
</TR>

<TR>
<TD>xrleloe , xrleltne , dfle2</TD>
<TD><I>none</I></TD>
<TD>Consequences of real trichotomy.</TD>
</TR>

<TR>
<TD>xrltlen</TD>
<TD><I>none</I></TD>
<TD>We presumably could prove an analogue to ~ ltleap but we have not
yet defined apartness for extended reals (` # ` is for complex
numbers).</TD>
</TR>

<TR>
<TD>dflt2</TD>
<TD><I>none</I></TD>
</TR>

<TR>
<TD>xrletri</TD>
<TD><I>none</I></TD>
</TR>

<TR>
<TD>xrmax1 , xrmax2 , xrmin1 , xrmin2 , xrmaxeq , xrmineq ,
xrmaxlt , xrltmin , xrmaxle , xrlemin , max1 , max2 , min1 , min2 ,
maxle , lemin , maxlt , ltmin , max0sub , ifle</TD>
<TD><I>none</I></TD>
</TR>

<TR>
<TD>qbtwnre , qbtwnxr</TD>
<TD><I>none yet</I></TD>
<TD>These should be provable, but the set.mm proof relies on zbtwnre
(which in turn is proved using the least upper bound property).
The most straightforward solution is to use a construction-dependent
proof in terms of ~ df-iltp (the only complicated part of which is
connecting ` Q. ` and ` QQ ` ). This is the solution adopted by
Theorem 11.2.6 of [HoTT].</TD>
</TR>

<TR>
<TD>qsqueeze</TD>
<TD><I>none yet</I></TD>
<TD>Once we have qbtwnre , we should be able to prove this as
a consequence of ~ squeeze0 .</TD>
</TR>

<TR>
<TD>qextltlem , qextlt , qextle</TD>
<TD><I>none</I></TD>
<TD>The set.mm proof is not intuitionistic.</TD>
</TR>

<TR>
<TD>xralrple , alrple</TD>
<TD><I>none yet</I></TD>
<TD>If we had qbtwnxr , it looks like the set.mm proof would work
with minor changes.</TD>
</TR>

<TR>
<TD>xnegex</TD>
<TD>~ xnegcl </TD>
</TR>

<TR>
<TD>xaddval , xaddf , xmulval , xaddpnf1 , xaddpnf2 , xaddmnf1 ,
xaddmnf2 , pnfaddmnf , mnfaddpnf , rexadd , rexsub , xaddnemnf ,
xaddnepnf , xnegid , xaddcl , xaddcom , xaddid1 , xaddid2 ,
xnegdi , xaddass , xaddass2 , xpncan , xnpcan , xleadd1a ,
xleadd2a , xleadd1 , xltadd1 , xltadd2 , xaddge0 , xle2add ,
xlt2add , xsubge0 , xposdif , xlesubadd , xmullem , xmullem2 ,
xmulcom , xmul01 , xmul02 , xmulneg1 , xmulneg2 , rexmul ,
xmulf , xmulcl , xmulpnf1 , xmulpnf2 , xmulmnf1 , xmulmnf2 ,
xmulpnf1n , xmulid1 , xmulid2 , xmulm1 , xmulasslem2 , xmulgt0 ,
xmulge0 , xmulasslem , xmulasslem3 , xmulass , xlemul1a ,
xlemul2a , xlemul1 , xlemul2 , xltmul1 , xltmul2 , xadddilem ,
xadddi , xadddir , xadddi2 , xadddi2r , x2times , xaddcld ,
xmulcld , xadd4d</TD>
<TD><I>none</I></TD>
<TD>There appears to be no fundamental obstacle to proving these,
because disjunctions can arise from ~ elxr rather than excluded
middle. However, ` -e ` , ` +e ` , and ` *e ` are lightly used in
set.mm, and the set.mm proofs would require significant changes.</TD>
</TR>

<TR>
<TD>ixxub , ixxlb</TD>
<TD><I>none</I></TD>
</TR>

<TR>
<TD>iccen</TD>
<TD><I>none</I></TD>
</TR>

<TR>
<TD>supicc , supiccub , supicclub , supicclub2</TD>
<TD><I>none</I></TD>
</TR>

<TR>
<TD>ixxun , ixxin</TD>
<TD><I>none</I></TD>
</TR>

<TR>
<TD>ioo0</TD>
<TD><I>none</I></TD>
<TD>Once we have qbtwnxr , it may be possible to rearrange
the logic from set.mm so that this proof works (via ~ rabeq0 ,
~ ralnex , and ~ xrlenlt perhaps).</TD>
</TR>

<TR>
<TD>ioon0</TD>
<TD><I>none</I></TD>
<TD>Presumably non-empty would need to be changed to inhabited,
see also discussion at ioo0</TD>
</TR>

<TR>
<TD>iooid</TD>
<TD>~ iooidg </TD>
</TR>

<TR>
<TD>ndmioo</TD>
<TD><I>none</I></TD>
<TD>See discussion at ndmov but set.mm uses excluded middle,
both in proving this and in using it.</TD>
</TR>

<TR>
<TD>lbioo , ubioo</TD>
<TD>~ lbioog , ~ ubioog </TD>
</TR>

<TR>
<TD>iooin</TD>
<TD><I>none</I></TD>
</TR>

<TR>
<TD>ico0 , ioc0</TD>
<TD><I>none</I></TD>
<TD>Possibly similar to ioo0 ; see discussion there.</TD>
</TR>

<TR>
<TD>icc0</TD>
<TD>~ icc0r </TD>
</TR>

<TR>
<TD>ioorebas</TD>
<TD>~ ioorebasg </TD>
</TR>

<TR>
<TD>ge0xaddcl , ge0xmulcl</TD>
<TD><I>none</I></TD>
<TD>Rely on xaddcl and xmulcl ; see discussion in this list
for those theorems.</TD>
</TR>

<TR>
<TD>icoun , snunioo , snunico , snunioc , prunioo</TD>
<TD><I>none</I></TD>
</TR>

<TR>
<TD>ioojoin</TD>
<TD><I>none</I></TD>
</TR>

<TR>
<TD>difreicc</TD>
<TD><I>none</I></TD>
</TR>

<TR>
<TD>iccsplit</TD>
<TD><I>none</I></TD>
<TD>This depends, apparently in an essential way, on real number
trichotomy.</TD>
</TR>

<TR>
<TD>xov1plusxeqvd</TD>
<TD><I>none</I></TD>
<TD>This presumably could be proved if not equal is changed
to apart, but is lightly used in set.mm.</TD>
</TR>

<TR>
<TD>fzn0</TD>
<TD>~ fzm </TD>
</TR>

<TR>
<TD>fz0</TD>
<TD><I>none</I></TD>
<TD>Although it would be possible to prove a version of this
with the additional conditions that ` M e. _V ` and ` N e. _V ` ,
the theorem is lightly used in set.mm.</TD>
</TR>

<TR>
<TD>fzon0</TD>
<TD>~ fzom </TD>
</TR>

<TR>
<TD>fzo0n0</TD>
<TD>~ fzo0m </TD>
</TR>

<TR>
<TD>ssfzoulel</TD>
<TD><I>none</I></TD>
<TD>Presumably could be proven, but the set.mm proof is not
intuitionistic and it is lightly used in set.mm.</TD>
</TR>

<TR>
<TD>fzonfzoufzol</TD>
<TD><I>none</I></TD>
<TD>Presumably could be proven, but the set.mm proof is not
intuitionistic and it is lightly used in set.mm.</TD>
</TR>

<TR>
<TD>elfznelfzo , elfznelfzob , injresinjlem , injresinj</TD>
<TD><I>none</I></TD>
<TD>Some or all of this presumably could be proven, but the set.mm
proof is not intuitionistic and it is lightly used in set.mm.</TD>
</TR>

<TR>
<TD>df-fl , df-ceil , and other floor and ceiling theoerms.</TD>
<TD><I>none</I></TD>
<TD>Most of the theorems in this section are conjectured to imply
excluded middle. Imagine a real number which is around 2.99995 or
3.00001 . In order to determine whether its floor is 2 or 3, it
would be necessary to compute the number to arbitrary precision.
For similarity to the Metamath Proof Explorer, it may be desirable
to define floor and ceiling, but only provide most of the theorems
where the argument is a rational number.</TD>
</TR>

<TR>
<TD>df-mod and other modulus theoerms.</TD>
<TD><I>none</I></TD>
<TD>As with df-fl it may be feasible to define this for rational
numbers rather than reals.</TD>
</TR>

<TR>
<TD>om2uz0i</TD>
<TD>~ frec2uz0d</TD>
</TR>

<TR>
<TD>om2uzsuci</TD>
<TD>~ frec2uzsucd</TD>
</TR>

<TR>
<TD>om2uzuzi</TD>
<TD>~ frec2uzuzd</TD>
</TR>

<TR>
<TD>om2uzlti</TD>
<TD>~ frec2uzltd</TD>
</TR>

<TR>
<TD>om2uzlt2i</TD>
<TD>~ frec2uzlt2d</TD>
</TR>

<TR>
<TD>om2uzrani</TD>
<TD>~ frec2uzrand</TD>
</TR>

<TR>
<TD>om2uzf1oi</TD>
<TD>~ frec2uzf1od</TD>
</TR>

<TR>
<TD>om2uzisoi</TD>
<TD>~ frec2uzisod</TD>
</TR>

<TR>
<TD>om2uzoi , ltweuz , ltwenn , ltwefz</TD>
<TD><I>none</I></TD>
<TD>We do not have a syntax for well ordering and based on
theorems like ~ nnregexmid , there is probably little room
for this concept.</TD>
</TR>

<TR>
<TD>om2uzrdg</TD>
<TD>~ frec2uzrdg</TD>
</TR>

<TR>
<TD>uzrdglem</TD>
<TD>~ frecuzrdglem</TD>
</TR>

<TR>
<TD>uzrdgfni</TD>
<TD>~ frecuzrdgfn</TD>
</TR>

<TR>
<TD>uzrdg0i</TD>
<TD>~ frecuzrdg0</TD>
</TR>

<TR>
<TD>uzrdgsuci</TD>
<TD>~ frecuzrdgsuc</TD>
</TR>

<TR>
<TD>uzinf</TD>
<TD><I>none</I></TD>
<TD>See ominf</TD>
</TR>

<TR>
<TD>uzrdgxfr</TD>
<TD><I>none</I></TD>
<TD>Presumably could be proved if restated in terms of ` frec `
(a la ~ frec2uz0d ). However, it is lightly used in set.mm.</TD>
</TR>

<TR>
<TD>fzennn</TD>
<TD>~ frecfzennn</TD>
</TR>

<TR>
<TD>fzen2</TD>
<TD>~ frecfzen2</TD>
</TR>

<TR>
<TD>cardfz</TD>
<TD><I>none</I></TD>
<TD>Cardinality does not work the same way without excluded
middle and iset.mm has few cardinality related theorems.</TD>
</TR>

<TR>
<TD>hashgf1o</TD>
<TD>~ frechashgf1o</TD>
</TR>

<TR>
<TD>fzfi</TD>
<TD>~ fzfig</TD>
</TR>

<TR>
<TD>fzfid</TD>
<TD>~ fzfigd</TD>
</TR>

<TR>
<TD>fzofi</TD>
<TD>~ fzofig</TD>
</TR>

<TR>
<TD>fsequb</TD>
<TD><I>none</I></TD>
<TD>Seems like it might be provable, but unused in set.mm</TD>
</TR>

<TR>
<TD>fsequb2</TD>
<TD><I>none</I></TD>
<TD>The set.mm proof does not work as-is</TD>
</TR>

<TR>
<TD>fseqsupcl , fseqsupubi</TD>
<TD><I>none</I></TD>
<TD>iset.mm does not have the "sup" syntax and lacks most
supremum theorems from set.mm.</TD>
</TR>

<TR>
<TD>uzindi</TD>
<TD><I>none</I></TD>
<TD>This could presumably be proved, perhaps from ~ uzind4 ,
but is lightly used in set.mm</TD>
</TR>

<TR>
<TD>axdc4uz</TD>
<TD><I>none</I></TD>
<TD>Although some versions of constructive mathematics accept dependent
choice, we have not yet developed it in iset.mm</TD>
</TR>

<TR>
<TD>ssnn0fi , rabssnn0fi</TD>
<TD><I>none</I></TD>
<TD>Conjectured to imply excluded middle along the lines of ~ nnregexmid
or ~ ssfiexmid </TD>
</TR>

<TR>
<TD>df-seq</TD>
<TD>~ df-iseq</TD>
</TR>

<TR>
<TD>seqex</TD>
<TD>~ iseqcl</TD>
</TR>

<TR>
<TD>seqeq1 , seqeq2 , seqeq3 , seqeq1d , seqeq2d , seqeq3d , seqeq123d</TD>
<TD>~ iseqeq1 , ~ iseqeq2 , ~ iseqeq3</TD>
</TR>

<TR>
<TD>nfseq</TD>
<TD>~ nfiseq</TD>
</TR>

<TR>
<TD>seqval</TD>
<TD>~ iseqval</TD>
</TR>

<TR>
<TD>seqfn</TD>
<TD>~ iseqfn</TD>
</TR>

<TR>
<TD>seq1 , seq1i</TD>
<TD>~ iseq1</TD>
</TR>

<TR>
<TD>seqp1 , seqp1i</TD>
<TD>~ iseqp1</TD>
</TR>

<TR>
<TD>seqcl</TD>
<TD>~ iseqcl</TD>
</TR>

<TR>
<TD>seqfveq2</TD>
<TD>~ iseqfveq2</TD>
</TR>

<TR>
<TD>seqfeq2</TD>
<TD>~ iseqfeq2</TD>
</TR>

<TR>
<TD>seqfveq</TD>
<TD>~ iseqfveq</TD>
</TR>

<TR>
<TD>df-exp</TD>
<TD>~ df-iexp</TD>
</TR>

<TR>
<TD>expval</TD>
<TD>~ expival</TD>
</TR>

<TR>
<TD>expnnval</TD>
<TD>~ expinnval</TD>
</TR>

<TR>
<TD>expneg</TD>
<TD>~ expnegap0</TD>
<TD>The set.mm theorem does not exclude the case of
dividing by zero.</TD>
</TR>

<TR>
<TD>expneg2</TD>
<TD>~ expineg2</TD>
</TR>

<TR>
<TD>expn1</TD>
<TD>~ expn1ap0</TD>
</TR>

<TR>
<TD>expcl2lem</TD>
<TD>~ expcl2lemap</TD>
</TR>

<TR>
<TD>reexpclz</TD>
<TD>~ reexpclzap</TD>
</TR>

<TR>
<TD>expclzlem</TD>
<TD>~ expclzaplem</TD>
</TR>

<TR>
<TD>expclz</TD>
<TD>~ expclzap</TD>
</TR>

<TR>
<TD>expne0</TD>
<TD>~ expap0</TD>
</TR>

<TR>
<TD>expne0i</TD>
<TD>~ expap0i</TD>
</TR>

<TR>
<TD>expnegz</TD>
<TD>~ expnegzap</TD>
</TR>

<TR>
<TD>mulexpz</TD>
<TD>~ mulexpzap</TD>
</TR>

<TR>
<TD>exprec</TD>
<TD>~ exprecap</TD>
</TR>

<TR>
<TD>expaddzlem , expaddz</TD>
<TD>~ expaddzaplem , ~ expaddzap</TD>
</TR>

<TR>
<TD>expmulz</TD>
<TD>~ expmulzap</TD>
</TR>

<TR>
<TD>expsub</TD>
<TD>~ expsubap</TD>
</TR>

<TR>
<TD>expp1z</TD>
<TD>~ expp1zap</TD>
</TR>

<TR>
<TD>expm1</TD>
<TD>~ expm1ap</TD>
</TR>

<TR>
<TD>expdiv</TD>
<TD>~ expdivap</TD>
</TR>

<TR>
<TD>expcan , expcand</TD>
<TD><I>none</I></TD>
<TD>Presumably provable, but the set.mm proof uses eqord1
and the theorem is lightly used in set.mm</TD>
</TR>

<TR>
<TD>ltexp2 , leexp2 , leexp2 , ltexp2d , leexp2d</TD>
<TD><I>none</I></TD>
<TD>Presumably provable, but the set.mm proof uses ltord1</TD>
</TR>

<TR>
<TD>ltexp2r , ltexp2rd</TD>
<TD><I>none</I></TD>
<TD>Presumably provable, but the set.mm proof uses ltexp2</TD>
</TR>

<TR>
<TD>sqdiv</TD>
<TD>~ sqdivap</TD>
</TR>

<TR>
<TD>sqgt0</TD>
<TD>~ sqgt0ap</TD>
</TR>

<TR>
<TD>iexpcyc</TD>
<TD><I>none yet</I></TD>
<TD>See discussion under df-mod ; modulus for integers would suffice
so issues with modulus for reals would not be an impediment.</TD>
</TR>

<TR>
<TD>sqrecii , sqrecd</TD>
<TD>~ exprecap</TD>
</TR>

<TR>
<TD>sqdivi</TD>
<TD>~ sqdivapi</TD>
</TR>

<TR>
<TD>sqgt0i</TD>
<TD>~ sqgt0api</TD>
</TR>

<TR>
<TD>sqlecan</TD>
<TD>~ lemul1</TD>
<TD>Unused in set.mm</TD>
</TR>

<TR>
<TD>sqeqori</TD>
<TD><I>none</I></TD>
<TD>The reverse direction is ~ oveq1 together with ~ sqneg .
The forward direction is presumably not provable, see mul0or for
more discussion.</TD>
</TR>

<TR>
<TD>subsq0i , sqeqor</TD>
<TD><I>none</I></TD>
<TD>Variations of sqeqori .</TD>
</TR>

<TR>
<TD>sq01</TD>
<TD><I>none</I></TD>
<TD>Lightly used in set.mm. Presumably not provable as stated,
for reasons analogous to mul0or .</TD>
</TR>

<TR>
<TD>crreczi</TD>
<TD><I>none</I></TD>
<TD>Presumably could be proved if not-equal is changed to apart,
but unused in set.mm.</TD>
</TR>

<TR>
<TD>expmulnbnd</TD>
<TD><I>none</I></TD>
<TD>Should be possible to prove this or something similar, but the
set.mm proof relies on case elimination based on whether ` 0 <_ A `
or not.</TD>
</TR>

<TR>
<TD>digit2 , digit1</TD>
<TD><I>none</I></TD>
<TD>Depends on modulus and floor, and unused in set.mm.</TD>
</TR>

<TR>
<TD>modexp</TD>
<TD><I>none</I></TD>
<TD>Depends on modulus. Presumably it, or something similar,
can be made to work as it is mostly about integers rather
than reals.</TD>
</TR>

<TR>
<TD>discr1 , discr</TD>
<TD><I>none</I></TD>
<TD>The set.mm proof uses real number trichotomy.</TD>
</TR>

<TR>
<TD>sqrecd</TD>
<TD>~ sqrecapd</TD>
</TR>

<TR>
<TD>expclzd</TD>
<TD>~ expclzapd</TD>
</TR>

<TR>
<TD>exp0d</TD>
<TD>~ expap0d</TD>
</TR>

<TR>
<TD>expnegd</TD>
<TD>~ expnegapd</TD>
</TR>

<TR>
<TD>exprecd</TD>
<TD>~ exprecapd</TD>
</TR>

<TR>
<TD>expp1zd</TD>
<TD>~ expp1zapd</TD>
</TR>

<TR>
<TD>expm1d</TD>
<TD>~ expm1apd</TD>
</TR>

<TR>
<TD>expsubd</TD>
<TD>~ expsubapd</TD>
</TR>

<TR>
<TD>sqdivd</TD>
<TD>~ sqdivapd</TD>
</TR>

<TR>
<TD>expdivd</TD>
<TD>~ expdivapd</TD>
</TR>

<TR>
<TD>reexpclzd</TD>
<TD>~ reexpclzapd</TD>
</TR>

<TR>
<TD>sqgt0d</TD>
<TD>~ sqgt0apd</TD>
</TR>

<TR>
<TD>mulre</TD>
<TD>~ mulreap</TD>
</TR>

<TR>
<TD>rediv</TD>
<TD>~ redivap</TD>
</TR>

<TR>
<TD>imdiv</TD>
<TD>~ imdivap</TD>
</TR>

<TR>
<TD>cjdiv</TD>
<TD>~ cjdivap</TD>
</TR>

<TR>
<TD>sqeqd</TD>
<TD><I>none</I></TD>
<TD>The set.mm proof is not intuitionistic, and this
theorem is unused in set.mm.</TD>
</TR>

<TR>
<TD>cjdivi</TD>
<TD>~ cjdivapi</TD>
</TR>

<TR>
<TD>cjdivd</TD>
<TD>~ cjdivapd</TD>
</TR>

<TR>
<TD>redivd</TD>
<TD>~ redivapd</TD>
</TR>

<TR>
<TD>imdivd</TD>
<TD>~ imdivapd</TD>
</TR>

<TR>
<TD>df-sqrt</TD>
<TD>~ df-rsqrt</TD>
<TD>See discussion of complex square roots in the comment of ~ df-rsqrt</TD>
</TR>

<TR>
<TD>sqrtval</TD>
<TD>~ sqrtrval</TD>
<TD>See discussion of complex square roots in the comment of ~ df-rsqrt</TD>
</TR>

<TR>
<TD>01sqrex and its lemmas</TD>
<TD><I>none</I></TD>
<TD>We have not yet defined real number completeness enough to prove the
existence of these square roots, but we expect we'll eventually be able
to prove this theorem from ~ cauappcvgpr or similar theorems.</TD>
</TR>

<TR>
<TD>cnpart</TD>
<TD><I>none</I></TD>
<TD>See discussion of complex square roots in the comment of ~ df-rsqrt</TD>
</TR>

<TR>
<TD>resqrex</TD>
<TD><I>none yet</I></TD>
<TD>This will be provable once completeness is better developed</TD>
</TR>

<TR>
<TD>sqrmo</TD>
<TD><I>none</I></TD>
<TD>See discussion of complex square roots in the comment of ~ df-rsqrt</TD>
</TR>

<TR>
<TD>resqreu</TD>
<TD><I>none yet</I></TD>
<TD>Once completeness is better developed, it should be possible to
adjust this to reflect ~ sqrtrval </TD>
</TR>

<TR>
<TD>resqrtcl</TD>
<TD><I>none yet</I></TD>
<TD>Once completeness is better developed, this will be provable
via resqrex</TD>
</TR>

<TR>
<TD>resqrtth , remsqsqrt</TD>
<TD><I>none yet</I></TD>
<TD>These will be provable once completeness is better developed</TD>
</TR>

<TR>
<TD>sqrtge0 , sqrtgt0</TD>
<TD><I>none yet</I></TD>
<TD>These will be provable once completeness is better developed</TD>
</TR>

<TR>
<TD>sqrtmul , sqrtle , sqrtlt , sqrt11 , sqrt00</TD>
<TD><I>none yet</I></TD>
<TD>These should be provable once completeness is better developed</TD>
</TR>

<TR>
<TD>rpsqrtcl</TD>
<TD><I>none yet</I></TD>
<TD>This is a variation of sqrtgt0</TD>
</TR>

<TR>
<TD>sqrtdiv</TD>
<TD><I>none yet</I></TD>
<TD>Should be provable once completeness is better developed</TD>
</TR>

<TR>
<TD>sqrtneg</TD>
<TD><I>none</I></TD>
<TD>Although it may be possible to extend the domain of square root
somewhat beyond nonnegative reals without excluded middle, in
general complex square roots are difficult, as discussed
in the comment of ~ df-rsqrt</TD>
</TR>

<TR>
<TD>sqrtsq2</TD>
<TD><I>none yet</I></TD>
<TD>Should be provable once completeness is better developed</TD>
</TR>

<TR>
<TD>sqrt2gt1lt2</TD>
<TD><I>none yet</I></TD>
<TD>Should be provable once completeness is better developed</TD>
</TR>

<TR>
<TD>sqrtm1</TD>
<TD><I>none</I></TD>
<TD>Although it may be possible to extend the domain of square root
somewhat beyond nonnegative reals without excluded middle, in
general complex square roots are difficult, as discussed
in the comment of ~ df-rsqrt</TD>
</TR>

<TR>
<TD>abscl</TD>
<TD><I>none yet</I></TD>
<TD>Should be easy once we get resqrtcl</TD>
</TR>

<TR>
<TD>absvalsq , absvalsq2 , sqabsadd , sqabssub</TD>
<TD><I>none yet</I></TD>
<TD>Should be easy once we prove resqrtth</TD>
</TR>

<TR>
<TD>absge0</TD>
<TD><I>none yet</I></TD>
<TD>Should be easy once we prove sqrtge0</TD>
</TR>

<TR>
<TD>absrpcl</TD>
<TD><I>none yet</I></TD>
<TD>Should be provable once we have proved completeness and
more of the square root theorems. Not equal presumably will
need to be changed to apart.</TD>
</TR>

<TR>
<TD>abs00 , abs00ad</TD>
<TD><I>none yet</I></TD>
<TD>Should be provable once we have proved completeness and
more of the square root theorems. We will presumably also be
able to prove ` ( ( abs `` A ) # 0 <-> A # 0 ` which is stronger and
is something we'd likely want.</TD>
</TR>

<TR>
<TD>absreimsq , absreim</TD>
<TD><I>none yet</I></TD>
<TD>Should be provable once we have proved absvalsq2</TD>
</TR>

<TR>
<TD>absmul</TD>
<TD><I>none yet</I></TD>
<TD>Should be provable once we have proved sqrtmul</TD>
</TR>

<TR>
<TD>absdiv</TD>
<TD><I>none yet</I></TD>
<TD>Should be provable once we have proved completeness and
more of the square root theorems. Not equal will
need to be changed to apart.</TD>
</TR>

<TR>
<TD>leabs</TD>
<TD><I>none</I></TD>
<TD>The set.mm proof relies on real number trichotomy. Here is a
sketch of a proof which might work once absge0 is proved. Suppose
` ( abs `` A ) < A ` . By ~ sowlin , ` ( abs `` A ) < 0 \/ 0 < A ` .
But absge0 tells us that ` ( abs `` A ) < 0 ` is not possible,
and ` 0 < A ` implies ` ( abs `` A ) = A ` via ~ absid .
This is a contradiction so ` -. ( abs `` A ) < A ` , which by
~ lenlt implies ` A <_ ( abs `` A ) ` .</TD>
</TR>

<TR>
<TD>absor</TD>
<TD><I>none</I></TD>
<TD>We could prove this for rationals if we wanted</TD>
</TR>

<TR>
<TD>absresq</TD>
<TD><I>none yet</I></TD>
<TD>This will follow once we have proved absvalsq</TD>
</TR>

<TR>
<TD>absmod0</TD>
<TD><I>none</I></TD>
<TD>See df-mod ; we may want to supply this for rationals or integers</TD>
</TR>

<TR>
<TD>absexp</TD>
<TD><I>none yet</I></TD>
<TD>Should be provable once we have proved absmul</TD>
</TR>

<TR>
<TD>absexpz</TD>
<TD><I>none yet</I></TD>
<TD>Should be provable, with not equal changed to apart,
once we have proved absexp</TD>
</TR>

<TR>
<TD>abssq , sqabs</TD>
<TD><I>none yet</I></TD>
<TD>Should be provable once we have absexp or other completeness
related results</TD>
</TR>

<TR>
<TD>absrele , absimle</TD>
<TD><I>none yet</I></TD>
<TD>Should be provable once we have proved sqrtle</TD>
</TR>

<TR>
<TD>max0add</TD>
<TD><I>none</I></TD>
<TD>Relies on real number trichotomy</TD>
</TR>

<TR>
<TD>absz</TD>
<TD><I>none</I></TD>
<TD>Although this is presumably provable, the set.mm proof is not
intuitionistic and it is lightly used in set.mm</TD>
</TR>

</TABLE>

<HR NOSHADE SIZE=1><A NAME="bib"></A><B><FONT
COLOR="#006633">Bibliography</FONT></B>&nbsp;&nbsp;&nbsp;

<OL>

<LI><A NAME="Apostol"></A> [Apostol] Apostol, Tom M.,
<I>Calculus,</I> vol. 1, 2nd ed.,
John Wiley &amp; Sons Inc. (1967) [QA300.A645 1967].</LI>

<LI><A NAME="Bauer"></A> [Bauer] Bauer, Andrej, &quot;Five stages of
accepting constructive mathematics,&quot; <I>Bulletin (New Series) of
the American Mathematical Society</I>, 54:481-498 (2017),
DOI: <A HREF="http://dx.doi.org/10.1090/bull/1556">10.1090/bull/1556</A> .</LI>

<LI><A NAME="BauerTaylor"></A> [BauerTaylor] Andrej Bauer and Paul Taylor,
"The Dedekind Reals in Abstract Stone Duality",
<I>Mathematical structures in computer science</I>, 19(4):757&#x2013;838, 2009,
<A HREF="http://www.paultaylor.eu/ASD/dedras.pdf">
http://www.paultaylor.eu/ASD/dedras.pdf</A>
</LI>

<LI><A NAME="BellMachover"></A> [BellMachover] Bell, J. L., and M.
Machover, <I>A Course in Mathematical Logic,</I> North-Holland,
Amsterdam (1977) [QA9.B3953].</LI>

<LI><A NAME="Bobzien"></A> [Bobzien] Bobzien, Susanne,
"Stoic Logic",
<I>The Cambridge Companion to Stoic Philosophy</I>,
Brad Inwood (ed.), Cambridge University Press (2003-2006),
<A HREF="https://philpapers.org/rec/BOBSL">
https://philpapers.org/rec/BOBSL</A>.

<LI><A NAME="BourbakiEns"></A> [BourbakiEns] Bourbaki, Nicolas,
<I>Th&eacute;orie des ensembles,</I> Springer-Verlag,
Berlin Heidelberg (2007); available in English (for purchase) at
<A HREF="http://www.springer.com/us/book/9783540225256">
http://www.springer.com/us/book/9783540225256</A> (retrieved
15-Aug-2016). Page references in iset.mm are for the French edition.</LI>

<LI><A NAME="BourbakiTop1"></A> [BourbakiTop1] Bourbaki, Nicolas, <I>Topologie
g&eacute;n&eacute;rale, Chapitres 1 &agrave; 4,</I> Springer-Verlag,
Berlin Heidelberg (2007); available in English (for purchase) at
<A HREF="http://www.springer.com/us/book/9783540642411">
http://www.springer.com/us/book/9783540642411</A> (retrieved
15-Aug-2016). Page references in set.mm are for the French edition.</LI>

<LI><A NAME="ChoquetDD"></A> [ChoquetDD] Choquet-Bruhat, Yvonne and Cecile
DeWitt-Morette, with Margaret Dillard-Bleick, <I>Analysis, Manifolds and
Physics,</I> Elsevier Science B.V., Amsterdam (1982) [QC20.7.A5C48
1981].</LI>

<LI><A NAME="Crosilla"></A> [Crosilla] Crosilla, Laura,
&quot;Set Theory: Constructive and Intuitionistic ZF&quot;, <I>The
Stanford Encyclopedia of Philosophy</I> (Summer 2015 Edition),
Edward N. Zalta (ed.), <A
HREF="https://plato.stanford.edu/archives/sum2015/entries/set-theory-constructive/">
https://plato.stanford.edu/archives/sum2015/entries/set-theory-constructive/</A>.
</LI>

<LI><A NAME="Moschovakis"></A> [Moschovakis] Moschovakis, Joan, &quot;Intuitionistic Logic&quot;, <I>The Stanford Encyclopedia of Philosophy (Spring 2015 Edition)</I>, Edward N. Zalta (ed.), <A HREF="https://plato.stanford.edu/archives/spr2015/entries/logic-intuitionistic/">https://plato.stanford.edu/archives/spr2015/entries/logic-intuitionistic/</A>.
</LI>

<LI><A NAME="Eisenberg"></A> [Eisenberg] Eisenberg, Murray, <I>Axiomatic Theory of
Sets and Classes,</I> Holt, Rinehart and Winston, Inc., New York (1971)
[QA248.E36].</LI>

<LI><A NAME="Enderton"></A> [Enderton] Enderton, Herbert B., <I>Elements of Set
Theory,</I> Academic Press, Inc., San Diego, California (1977)
[QA248.E5].</LI>

<LI><A NAME="Gleason"></A> [Gleason] Gleason, Andrew M., <I>Fundamentals of
Abstract Analysis,</I> Jones and Bartlett Publishers, Boston (1991)
[QA300.G554].</LI>

<LI><A NAME="Geuvers"></A> [Geuvers] Herman Geuvers, Randy Pollack, Freek
Wiedijk, Jan Zwanenburg, "Skeleton for the Proof development leading to
the Fundamental Theorem of Algebra", October 2, 2000,
<A HREF="http://www.cs.ru.nl/~~herman/PUBS/FTA.mathproof.ps.gz"
>http://www.cs.ru.nl/~~herman/PUBS/FTA.mathproof.ps.gz</A> (accessed
19 Feb 2020).</LI>

<LI><A NAME="Hamilton"></A> [Hamilton] Hamilton, A. G., <I>Logic for
Mathematicians,</I> Cambridge University Press, Cambridge, revised
edition (1988) [QA9.H298 1988].</LI>

<LI><A NAME="Heyting"></A> [Heyting] Heyting, A., <I>Intuitionism: An
introduction</I>, North-Holland publishing company, Amsterdam, second
edition (1966).</LI>

<LI><A NAME="Hitchcock"></A> [Hitchcock] Hitchcock, David, <I>The
peculiarities of Stoic propositional logic</I>, McMaster University;
available at <A
HREF="http://www.humanities.mcmaster.ca/~~hitchckd/peculiarities.pdf">
http://www.humanities.mcmaster.ca/~~hitchckd/peculiarities.pdf</A>
(retrieved 3 Jul 2016).</LI>

<LI><A NAME="HoTT"></A> [HoTT] The Univalent Foundations Program,
<I>Homotopy Type Theory: Univalent Foundations of Mathematics</I>,
<A HREF="https://homotopytypetheory.org/book"
>https://homotopytypetheory.org/book</A>, first edition.</LI>

<LI><A NAME="Jech"></A> [Jech] Jech, Thomas, <I>Set Theory,</I>
Academic Press, San Diego (1978) [QA248.J42].</LI>

<LI><A NAME="KalishMontague"></A> [KalishMontague] Kalish, D. and R.
Montague, &quot;On Tarski's formalization of predicate logic with
identity,&quot; <I>Archiv f&uuml;r Mathematische Logik und
Grundlagenforschung,</I> 7:81-101 (1965) [QA.A673].</LI>

<LI><A NAME="Kreyszig"></A> [Kreyszig] Kreysig, Erwin, <I>Introductory
Functional Analysis with Applications</I>, John Wiley &amp; Sons, New
York (1989) [QA320.K74].  </LI>

<LI><A NAME="Kunen"></A> [Kunen] Kunen, Kenneth, <I>Set Theory:  An
Introduction to Independence Proofs,</I> Elsevier Science B.V.,
Amsterdam (1980) [QA248.K75].</LI>

<LI><A NAME="KuratowskiMostowski"></A> [KuratowskiMostowski] Kuratowski, K.
and A. Mostowski, <I>Set Theory: with an Introduction to
Descriptive Set Theory,</I> 2nd ed., North-Holland,
Amsterdam (1976) [QA248.K7683 1976].</LI>

<LI><A NAME="Levy"></A> [Levy] Levy, Azriel, <I>Basic Set Theory</I>,
Dover Publications, Mineola, N.Y. (2002) [QA248.L398 2002]. </LI>

<LI><A NAME="Lopez-Astorga"></A> [Lopez-Astorga] Lopez-Astorga, Miguel,
"The First Rule of Stoic Logic and its Relationship with the
Indemonstrables", <I>Revista de Filosof&#xED;a T&#xF3;picos</I>
(2016); available
at <A HREF="http://www.scielo.org.mx/pdf/trf/n50/n50a1.pdf">
http://www.scielo.org.mx/pdf/trf/n50/n50a1.pdf</A> (retrieved 3 Jul
2016).</LI>

<LI><A NAME="Margaris"></A> [Margaris] Margaris, Angelo, <I>First Order
Mathematical Logic,</I> Blaisdell Publishing Company, Waltham,
Massachusetts (1967) [QA9.M327].</LI>

<LI><A NAME="Megill"></A><A NAME="bibmegill"></A> [Megill] Megill, N.,
&quot;A Finitely Axiomatized Formalization of Predicate Calculus with
Equality,&quot; <I>Notre Dame Journal of Formal Logic,</I> 36:435-453
(1995) [QA.N914]; available at  <A
HREF="http://projecteuclid.org/euclid.ndjfl/1040149359"
>http://projecteuclid.org/euclid.ndjfl/1040149359</A> (accessed
11 Nov 2014); the <A HREF="../downloads/finiteaxiom.pdf">PDF
preprint</A> has the same content (with corrections) but pages are
numbered 1-22, and the database references use the numbers printed on the
page itself, not the PDF page numbers.</LI>

<LI><A NAME="Mendelson"></A> [Mendelson] Mendelson, Elliott, <I>Introduction to
Mathematical Logic,</I> 2nd ed., D. Van Nostrand (1979) [QA9.M537].</LI>

<LI><A NAME="Monk1"></A> [Monk1] Monk, J. Donald, <I>Introduction to Set
Theory,</I> McGraw-Hill, Inc. (1969) [QA248.M745].</LI>

<LI><A NAME="Monk2"></A> [Monk2] Monk, J. Donald, &quot;Substitutionless
Predicate Logic with Identity,&quot; <I>Archiv f&uuml;r Mathematische Logik
und Grundlagenforschung,</I> 7:103-121 (1965) [QA.A673].</LI>

<LI><A NAME="Quine"></A> [Quine] Quine, Willard van Orman, <I>Set Theory
and Its Logic,</I> Harvard University Press, Cambridge, Massachusetts,
revised edition (1969) [QA248.Q7 1969].</LI>

<LI><A NAME="Sanford"></A> [Sanford] Sanford, David H., <I>If P, then Q:
Conditionals and the Foundations of Reasoning</I>, 2nd ed., Routledge
Taylor &amp; Francis Group (2003); ISBN 0-415-28369-8; available at <A
HREF="https://books.google.com/books?id=h_AUynB6PA8C&amp;pg=PA39#v=onepage&amp;q&amp;f=false">https://books.google.com/books?id=h_AUynB6PA8C&amp;pg=PA39#v=onepage&amp;q&amp;f=false</A>
(retrieved 3 Jul 2016).</LI>

<LI><A NAME="Schechter"></A> [Schechter] Schechter, Eric, <I>Handbook of
Analysis and Its Foundations</I>, Academic Press, San Diego (1997)
[QA300.S339].</LI>

<LI><A NAME="Stoll"></A> [Stoll] Stoll, Robert R., <I>Set Theory and Logic,</I>
Dover Publications, Inc. (1979) [QA248.S7985 1979].</LI>

<LI><A NAME="Suppes"></A> [Suppes] Suppes, Patrick, <I>Axiomatic Set Theory,</I>
Dover Publications, Inc. (1972) [QA248.S959].</LI>

<LI><A NAME="TakeutiZaring"></A> [TakeutiZaring] Takeuti, Gaisi, and
Wilson M. Zaring, <I>Introduction to Axiomatic Set Theory,</I>
Springer-Verlag, New York, second edition (1982) [QA248.T136 1982].</LI>

<LI><A NAME="Tarski"></A> [Tarski] Tarski, Alfred, &quot;A Simplified
Formalization of Predicate Logic with Identity,&quot; <I>Archiv f&uuml;r
Mathematische Logik und Grundlagenforschung,</I> 7:61-79 (1965)
[QA.A673].</LI>

<LI><A NAME="WhiteheadRussell"></A> [WhiteheadRussell] Whitehead, Alfred
North, and Bertrand Russell, <I>Principia Mathematica to *56,</I>
Cambridge University Press, Cambridge, 1962 [QA9.W592 1962].</LI>

</OL>


<HR NOSHADE SIZE=1>

<TABLE BORDER=0 WIDTH="100%"><TR>

<TD ALIGN=LEFT VALIGN=TOP WIDTH="25%"><FONT SIZE=-2 FACE=sans-serif>
&nbsp;</FONT></TD>

<TD NOWRAP ALIGN=CENTER><I><FONT SIZE=-1>This
 page was last updated on 15-Aug-2015.</FONT></I><BR><FONT
FACE="ARIAL" SIZE=-2>Your
 comments are welcome:
Norman Megill <A HREF="../email.html"><IMG BORDER=0
SRC="_nmemail.gif"
ALT="nm at alum dot mit dot edu"
TITLE="nm at alum dot mit dot edu"
 WIDTH=90 HEIGHT=13 STYLE="margin-bottom:-3px"></A><BR>
Copyright terms:
<A HREF="../copyright.html#pd">Public domain</A></FONT></TD>

<TD ALIGN=RIGHT VALIGN=BOTTOM WIDTH="25%">
<FONT FACE="ARIAL" SIZE=-2>
<A
HREF="http://validator.w3.org/check?uri=referer">W3C HTML validation</A>
[external]
</FONT>
</TD>

</TR></TABLE>

</BODY>
</HTML>
